CCS PCM C Compiler, Version 5.025, 7477               28-Jun-22 22:55

               Filename:   E:\PICC\BTL\cal.lst

               ROM used:   5865 words (72%)
                           Largest free fragment is 2048
               RAM used:   8 (2%) at main() level
                           103 (28%) worst case
               Stack used: 3 locations
               Stack size: 8

*
0000:  MOVLW  0F
0001:  MOVWF  0A
0002:  GOTO   763
0003:  NOP
.................... #include <cal.h> 
.................... #include <16F877A.h> 
.................... //////////// Standard Header file for the PIC16F877A device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F877A 
0004:  DATA CC,37
0005:  DATA 69,10
0006:  DATA D3,2C
0007:  DATA 4E,2A
0008:  DATA 41,2C
0009:  DATA 00,00
000A:  DATA 43,34
000B:  DATA 69,10
000C:  DATA 6E,34
000D:  DATA 61,38
000E:  DATA A0,35
000F:  DATA 69,10
0010:  DATA F4,3A
0011:  DATA A0,39
0012:  DATA 6F,16
0013:  DATA A0,36
0014:  DATA EF,34
0015:  DATA 20,37
0016:  DATA E8,30
0017:  DATA 70,10
0018:  DATA EC,30
0019:  DATA 69,00
001A:  DATA 50,34
001B:  DATA 65,38
001C:  DATA 20,3A
001D:  DATA EF,30
001E:  DATA 6E,10
001F:  DATA E4,37
0020:  DATA 6E,10
0021:  DATA E7,34
0022:  DATA 61,37
0023:  DATA 3A,10
0024:  DATA 6E,34
0025:  DATA 61,37
0026:  DATA 20,2A
0027:  DATA 20,34
0028:  DATA EF,30
0029:  DATA 63,10
002A:  DATA 74,00
002B:  DATA C7,34
002C:  DATA E1,34
002D:  DATA 20,38
002E:  DATA E8,3A
002F:  DATA 6F,37
0030:  DATA 67,10
0031:  DATA 74,39
0032:  DATA 69,37
0033:  DATA 68,10
0034:  DATA E2,30
0035:  DATA 63,10
0036:  DATA 31,1D
0037:  DATA 20,37
0038:  DATA E8,30
0039:  DATA 6E,10
003A:  DATA 50,10
003B:  DATA E8,37
003C:  DATA E1,31
003D:  DATA 20,38
003E:  DATA 00,01
003F:  DATA D4,34
0040:  DATA 6E,34
0041:  DATA A0,39
0042:  DATA 6F,10
0043:  DATA ED,3A
0044:  DATA A0,30
0045:  DATA 5E,31
0046:  DATA 3A,10
0047:  DATA 6E,34
0048:  DATA 61,37
0049:  DATA A0,26
004A:  DATA 20,34
004B:  DATA EF,30
004C:  DATA 63,10
004D:  DATA 6D,00
004E:  DATA 54,39
004F:  DATA 69,10
0050:  DATA F4,3A
0051:  DATA F9,32
0052:  DATA 74,10
0053:  DATA E4,37
0054:  DATA 69,1D
0055:  DATA 20,37
0056:  DATA E8,30
0057:  DATA 6E,10
0058:  DATA 44,10
0059:  DATA E8,37
005A:  DATA E1,31
005B:  DATA 20,32
005C:  DATA 00,01
005D:  DATA CB,34
005E:  DATA E5,36
005F:  DATA 20,3A
0060:  DATA F2,30
0061:  DATA A0,39
0062:  DATA 6F,10
0063:  DATA EE,33
0064:  DATA F5,3C
0065:  DATA 65,37
0066:  DATA 20,3A
0067:  DATA 6F,10
0068:  DATA 6E,34
0069:  DATA 61,37
006A:  DATA 20,27
006B:  DATA 20,34
006C:  DATA EF,30
006D:  DATA 63,10
006E:  DATA 6E,00
006F:  DATA 50,34
0070:  DATA 65,38
0071:  DATA 20,3A
0072:  DATA 69,37
0073:  DATA 68,10
0074:  DATA E4,37
0075:  DATA 6E,10
0076:  DATA E7,34
0077:  DATA 61,37
0078:  DATA 00,01
0079:  DATA 4E,34
007A:  DATA 61,38
007B:  DATA A0,30
007C:  DATA 3A,10
007D:  DATA 00,01
007E:  DATA 4E,34
007F:  DATA 61,38
0080:  DATA 20,31
0081:  DATA 3A,10
0082:  DATA 00,01
0083:  DATA 4E,34
0084:  DATA 61,38
0085:  DATA 20,38
0086:  DATA E8,32
0087:  DATA 70,10
0088:  DATA F4,34
0089:  DATA 6E,34
008A:  DATA 3A,10
008B:  DATA 00,01
008C:  DATA CB,32
008D:  DATA 74,10
008E:  DATA F1,3A
008F:  DATA 61,10
0090:  DATA 25,36
0091:  DATA 64,10
0092:  DATA 2B,10
0093:  DATA 25,36
0094:  DATA 64,10
0095:  DATA 3D,10
0096:  DATA 25,36
0097:  DATA 64,00
0098:  DATA CB,32
0099:  DATA 74,10
009A:  DATA F1,3A
009B:  DATA 61,10
009C:  DATA 25,36
009D:  DATA 64,10
009E:  DATA 2D,10
009F:  DATA 25,36
00A0:  DATA 64,10
00A1:  DATA 3D,10
00A2:  DATA 25,36
00A3:  DATA 64,00
00A4:  DATA CB,32
00A5:  DATA 74,10
00A6:  DATA F1,3A
00A7:  DATA 61,10
00A8:  DATA 25,36
00A9:  DATA 64,10
00AA:  DATA 2A,10
00AB:  DATA 25,36
00AC:  DATA 64,10
00AD:  DATA 3D,10
00AE:  DATA 25,36
00AF:  DATA 64,00
00B0:  DATA CB,32
00B1:  DATA 74,10
00B2:  DATA F1,3A
00B3:  DATA 61,10
00B4:  DATA 25,36
00B5:  DATA 64,10
00B6:  DATA 2F,10
00B7:  DATA 25,36
00B8:  DATA 64,10
00B9:  DATA 3D,10
00BA:  DATA 25,33
00BB:  DATA 00,0F
00BC:  DATA 50,34
00BD:  DATA F5,37
00BE:  DATA EE,33
00BF:  DATA 20,3A
00C0:  DATA F2,34
00C1:  DATA 6E,34
00C2:  DATA 20,31
00C3:  DATA E1,31
00C4:  DATA A0,18
00C5:  DATA 3A,10
00C6:  DATA 61,3C
00C7:  DATA A0,15
00C8:  DATA 20,31
00C9:  DATA A0,1E
00CA:  DATA A0,31
00CB:  DATA 00,01
00CC:  DATA 4E,34
00CD:  DATA 61,38
00CE:  DATA A0,30
00CF:  DATA 3A,10
00D0:  DATA 00,01
00D1:  DATA 4E,34
00D2:  DATA 61,38
00D3:  DATA 20,31
00D4:  DATA 3A,10
00D5:  DATA 00,01
00D6:  DATA 4E,34
00D7:  DATA 61,38
00D8:  DATA A0,31
00D9:  DATA 3A,10
00DA:  DATA 00,01
00DB:  DATA 78,10
00DC:  DATA 3D,10
00DD:  DATA 25,33
00DE:  DATA 00,01
00DF:  DATA D4,34
00E0:  DATA 6E,34
00E1:  DATA A0,39
00E2:  DATA 6F,10
00E3:  DATA ED,3A
00E4:  DATA 00,01
00E5:  DATA 4E,34
00E6:  DATA 61,38
00E7:  DATA A0,30
00E8:  DATA 3A,10
00E9:  DATA 00,01
00EA:  DATA 4E,34
00EB:  DATA 61,38
00EC:  DATA 20,31
00ED:  DATA 3A,10
00EE:  DATA 00,01
00EF:  DATA 54,39
00F0:  DATA 69,10
00F1:  DATA F4,3A
00F2:  DATA F9,32
00F3:  DATA 74,10
00F4:  DATA E4,37
00F5:  DATA 69,00
00F6:  DATA 4E,34
00F7:  DATA 61,38
00F8:  DATA A0,30
00F9:  DATA 3A,10
00FA:  DATA 00,01
00FB:  DATA FC,12
00FC:  DATA 6C,32
00FD:  DATA 7C,10
00FE:  DATA 3D,10
00FF:  DATA 25,36
0100:  DATA 64,00
0101:  DATA FC,12
0102:  DATA 6C,32
0103:  DATA 7C,10
0104:  DATA 3D,10
0105:  DATA 25,36
0106:  DATA 64,00
0107:  DATA CB,34
0108:  DATA E5,36
0109:  DATA 20,3A
010A:  DATA F2,30
010B:  DATA A0,39
010C:  DATA 6F,10
010D:  DATA EE,33
010E:  DATA F5,3C
010F:  DATA 65,37
0110:  DATA 20,3A
0111:  DATA 6F,00
0112:  DATA 4E,34
0113:  DATA 61,38
0114:  DATA A0,30
0115:  DATA 3A,10
0116:  DATA 00,01
0117:  DATA 61,10
0118:  DATA 6B,34
0119:  DATA 6F,37
011A:  DATA 67,10
011B:  DATA 70,34
011C:  DATA E1,34
011D:  DATA A0,39
011E:  DATA 6F,10
011F:  DATA EE,33
0120:  DATA F5,3C
0121:  DATA 65,37
0122:  DATA 20,3A
0123:  DATA 6F,00
0124:  DATA 61,10
0125:  DATA 6B,34
0126:  DATA 6F,37
0127:  DATA 67,10
0128:  DATA 70,34
0129:  DATA E1,34
012A:  DATA A0,39
012B:  DATA 6F,10
012C:  DATA EE,33
012D:  DATA F5,3C
012E:  DATA 65,37
012F:  DATA 20,3A
0130:  DATA 6F,00
0131:  DATA 61,10
0132:  DATA EC,30
0133:  DATA A0,39
0134:  DATA 6F,10
0135:  DATA EE,33
0136:  DATA F5,3C
0137:  DATA 65,37
0138:  DATA 20,3A
0139:  DATA 6F,00
013A:  DATA 61,10
013B:  DATA 6B,34
013C:  DATA 6F,37
013D:  DATA 67,10
013E:  DATA 70,34
013F:  DATA E1,34
0140:  DATA A0,39
0141:  DATA 6F,10
0142:  DATA EE,33
0143:  DATA F5,3C
0144:  DATA 65,37
0145:  DATA 20,3A
0146:  DATA 6F,00
0147:  DATA 50,34
0148:  DATA 65,38
0149:  DATA 20,3A
014A:  DATA EF,30
014B:  DATA 6E,10
014C:  DATA E4,37
014D:  DATA 6E,10
014E:  DATA E7,34
014F:  DATA 61,37
0150:  DATA 3A,10
0151:  DATA 6E,34
0152:  DATA 61,37
0153:  DATA 20,2A
0154:  DATA 20,34
0155:  DATA EF,30
0156:  DATA 63,10
0157:  DATA 74,00
0158:  DATA D4,34
0159:  DATA 6E,34
015A:  DATA 20,31
015B:  DATA E9,32
015C:  DATA 6E,10
015D:  DATA E4,37
015E:  DATA 3A,10
015F:  DATA 6E,34
0160:  DATA 61,37
0161:  DATA 20,21
0162:  DATA 20,34
0163:  DATA EF,30
0164:  DATA 63,10
0165:  DATA 62,00
0166:  DATA D3,37
0167:  DATA 20,38
0168:  DATA E8,3A
0169:  DATA 63,10
016A:  DATA EC,34
016B:  DATA 65,37
016C:  DATA 20,34
016D:  DATA 6F,38
016E:  DATA 3A,10
016F:  DATA 6E,34
0170:  DATA 61,37
0171:  DATA 20,24
0172:  DATA 20,34
0173:  DATA EF,30
0174:  DATA 63,10
0175:  DATA 68,00
0176:  DATA D3,37
0177:  DATA 20,38
0178:  DATA E8,3A
0179:  DATA 63,10
017A:  DATA 31,1D
017B:  DATA A0,30
017C:  DATA 31,10
017D:  DATA 2B,10
017E:  DATA 6A,31
017F:  DATA 31,00
0180:  DATA 4E,34
0181:  DATA 61,38
0182:  DATA A0,30
0183:  DATA 31,1D
0184:  DATA 20,00
0185:  DATA 4E,34
0186:  DATA 61,38
0187:  DATA 20,31
0188:  DATA 31,1D
0189:  DATA 20,00
018A:  DATA D3,37
018B:  DATA 20,38
018C:  DATA E8,3A
018D:  DATA 63,10
018E:  DATA 32,1D
018F:  DATA A0,30
0190:  DATA 32,10
0191:  DATA 2B,10
0192:  DATA 6A,31
0193:  DATA 32,00
0194:  DATA 4E,34
0195:  DATA 61,38
0196:  DATA A0,30
0197:  DATA 32,1D
0198:  DATA 20,00
0199:  DATA 4E,34
019A:  DATA 61,38
019B:  DATA 20,31
019C:  DATA 32,1D
019D:  DATA 20,00
019E:  DATA 4E,34
019F:  DATA 61,38
01A0:  DATA 20,38
01A1:  DATA E8,32
01A2:  DATA 70,10
01A3:  DATA F4,34
01A4:  DATA 6E,34
01A5:  DATA 3A,10
01A6:  DATA 00,01
01A7:  DATA CB,32
01A8:  DATA 74,10
01A9:  DATA F1,3A
01AA:  DATA 61,10
01AB:  DATA EC,30
01AC:  DATA 3A,10
01AD:  DATA 25,36
01AE:  DATA 64,10
01AF:  DATA 2B,10
01B0:  DATA 6A,14
01B1:  DATA 25,36
01B2:  DATA E4,14
01B3:  DATA 00,01
01B4:  DATA CB,32
01B5:  DATA 74,10
01B6:  DATA F1,3A
01B7:  DATA 61,10
01B8:  DATA EC,30
01B9:  DATA 3A,10
01BA:  DATA 25,36
01BB:  DATA 64,10
01BC:  DATA 2B,10
01BD:  DATA 6A,14
01BE:  DATA 25,36
01BF:  DATA E4,14
01C0:  DATA 00,01
01C1:  DATA CB,32
01C2:  DATA 74,10
01C3:  DATA F1,3A
01C4:  DATA 61,10
01C5:  DATA EC,30
01C6:  DATA 3A,10
01C7:  DATA 25,36
01C8:  DATA 64,10
01C9:  DATA 2B,10
01CA:  DATA 6A,14
01CB:  DATA 25,36
01CC:  DATA E4,14
01CD:  DATA 00,01
01CE:  DATA CB,32
01CF:  DATA 74,10
01D0:  DATA F1,3A
01D1:  DATA 61,10
01D2:  DATA EC,30
01D3:  DATA 3A,10
01D4:  DATA 25,33
01D5:  DATA A0,15
01D6:  DATA 6A,14
01D7:  DATA 25,33
01D8:  DATA 29,00
01D9:  DATA D3,37
01DA:  DATA 20,38
01DB:  DATA E8,3A
01DC:  DATA 63,10
01DD:  DATA BA,20
01DE:  DATA A0,1E
01DF:  DATA A0,30
01E0:  DATA A0,15
01E1:  DATA 20,35
01E2:  DATA 62,00
01E3:  DATA 4E,34
01E4:  DATA 61,38
01E5:  DATA A0,30
01E6:  DATA 3A,10
01E7:  DATA 00,01
01E8:  DATA 4E,34
01E9:  DATA 61,38
01EA:  DATA 20,31
01EB:  DATA 3A,10
01EC:  DATA 00,01
01ED:  DATA C2,34
01EE:  DATA 65,37
01EF:  DATA 20,32
01F0:  DATA 6F,10
01F1:  DATA 3D,10
01F2:  DATA 25,33
01F3:  DATA 00,01
01F4:  DATA D3,37
01F5:  DATA 20,38
01F6:  DATA E8,3A
01F7:  DATA 63,10
01F8:  DATA BA,20
01F9:  DATA A0,1E
01FA:  DATA A0,30
01FB:  DATA A0,15
01FC:  DATA 20,35
01FD:  DATA 62,00
01FE:  DATA 4E,34
01FF:  DATA 61,38
0200:  DATA A0,30
0201:  DATA 3A,10
0202:  DATA 00,01
0203:  DATA 4E,34
0204:  DATA 61,38
0205:  DATA 20,31
0206:  DATA 3A,10
0207:  DATA 00,01
0208:  DATA CB,32
0209:  DATA 74,10
020A:  DATA F1,3A
020B:  DATA 61,10
020C:  DATA EC,30
020D:  DATA 3A,10
020E:  DATA 25,36
020F:  DATA 64,10
0210:  DATA 2B,10
0211:  DATA 6A,14
0212:  DATA 25,36
0213:  DATA E4,14
0214:  DATA 00,01
0215:  DATA CB,32
0216:  DATA 74,10
0217:  DATA 74,34
0218:  DATA F5,31
0219:  DATA A0,36
021A:  DATA E9,32
021B:  DATA 6E,10
021C:  DATA 70,34
021D:  DATA F5,31
021E:  DATA 00,00
021F:  DATA D3,37
0220:  DATA 20,38
0221:  DATA 69,1D
0222:  DATA 20,37
0223:  DATA E8,30
0224:  DATA 6E,10
0225:  DATA 50,10
0226:  DATA E8,37
0227:  DATA E1,31
0228:  DATA 20,38
0229:  DATA 00,01
022A:  DATA C8,30
022B:  DATA EE,33
022C:  DATA A0,39
022D:  DATA 6F,10
022E:  DATA F4,3A
022F:  DATA 20,3A
0230:  DATA E8,30
0231:  DATA 6D,10
0232:  DATA 75,1D
0233:  DATA 20,37
0234:  DATA E8,30
0235:  DATA 6E,10
0236:  DATA 75,00
0237:  DATA C8,30
0238:  DATA EE,33
0239:  DATA A0,39
023A:  DATA 6F,10
023B:  DATA E4,34
023C:  DATA 65,37
023D:  DATA 20,3A
023E:  DATA E8,30
023F:  DATA 6D,10
0240:  DATA 65,1D
0241:  DATA 20,37
0242:  DATA E8,30
0243:  DATA 6E,10
0244:  DATA D4,30
0245:  DATA 62,00
0246:  DATA C8,32
0247:  DATA A0,39
0248:  DATA 6F,10
0249:  DATA C5,3A
024A:  DATA EC,32
024B:  DATA 72,1D
024C:  DATA 20,37
024D:  DATA E8,30
024E:  DATA 6E,10
024F:  DATA 65,00
0250:  DATA D4,37
0251:  DATA 63,10
0252:  DATA E4,37
0253:  DATA A0,30
0254:  DATA 6E,34
0255:  DATA A0,39
0256:  DATA 61,37
0257:  DATA 67,1D
0258:  DATA 20,37
0259:  DATA E8,30
025A:  DATA 6E,10
025B:  DATA 63,00
025C:  DATA F0,34
025D:  DATA A0,1E
025E:  DATA A0,19
025F:  DATA AE,18
0260:  DATA B4,18
0261:  DATA B5,1C
0262:  DATA 00,01
0263:  DATA C8,30
0264:  DATA EE,33
0265:  DATA A0,39
0266:  DATA 6F,10
0267:  DATA F4,3A
0268:  DATA 20,3A
0269:  DATA E8,30
026A:  DATA 6D,10
026B:  DATA 75,10
026C:  DATA 3D,10
026D:  DATA 34,38
026E:  DATA 69,3C
026F:  DATA 31,18
0270:  DATA DE,16
0271:  DATA 37,00
0272:  DATA C8,30
0273:  DATA EE,33
0274:  DATA A0,39
0275:  DATA 6F,10
0276:  DATA E4,34
0277:  DATA 65,37
0278:  DATA 20,3A
0279:  DATA E8,30
027A:  DATA 6D,10
027B:  DATA 65,10
027C:  DATA 3D,10
027D:  DATA 38,17
027E:  DATA B8,1A
027F:  DATA 34,19
0280:  DATA F8,18
0281:  DATA 30,2F
0282:  DATA AD,18
0283:  DATA 32,00
0284:  DATA C8,32
0285:  DATA A0,39
0286:  DATA 6F,10
0287:  DATA C5,3A
0288:  DATA EC,32
0289:  DATA A0,32
028A:  DATA A0,1E
028B:  DATA 20,19
028C:  DATA AE,1B
028D:  DATA 31,1C
028E:  DATA 32,1C
028F:  DATA 20,00
0290:  DATA D4,37
0291:  DATA 63,10
0292:  DATA E4,37
0293:  DATA A0,30
0294:  DATA 6E,34
0295:  DATA A0,39
0296:  DATA 61,37
0297:  DATA 67,10
0298:  DATA E3,1E
0299:  DATA 33,3C
029A:  DATA 31,18
029B:  DATA 5E,1C
029C:  DATA 00,00
029D:  DATA CD,34
029E:  DATA 65,37
029F:  DATA 20,3A
02A0:  DATA E8,3A
02A1:  DATA 63,1D
02A2:  DATA 20,37
02A3:  DATA E8,30
02A4:  DATA 6E,10
02A5:  DATA 52,10
02A6:  DATA E8,37
02A7:  DATA E1,31
02A8:  DATA 20,39
02A9:  DATA 00,01
02AA:  DATA CD,34
02AB:  DATA 65,37
02AC:  DATA 20,38
02AD:  DATA E8,3A
02AE:  DATA 63,1D
02AF:  DATA 20,37
02B0:  DATA E8,30
02B1:  DATA 6E,10
02B2:  DATA 43,10
02B3:  DATA E8,37
02B4:  DATA E1,31
02B5:  DATA A0,31
02B6:  DATA 00,01
02B7:  DATA C8,30
02B8:  DATA EE,33
02B9:  DATA A0,39
02BA:  DATA 6F,1D
02BB:  DATA 20,37
02BC:  DATA E8,30
02BD:  DATA 6E,10
02BE:  DATA 48,10
02BF:  DATA E8,37
02C0:  DATA E1,31
02C1:  DATA 20,34
02C2:  DATA 00,00
02C3:  DATA C2,30
02C4:  DATA 6E,10
02C5:  DATA E3,37
02C6:  DATA A0,36
02C7:  DATA F5,37
02C8:  DATA 6E,10
02C9:  DATA F4,34
02CA:  DATA 65,38
02CB:  DATA 20,3A
02CC:  DATA F5,31
02CD:  DATA 21,00
02CE:  DATA D4,34
02CF:  DATA 65,38
02D0:  DATA 20,3A
02D1:  DATA F5,31
02D2:  DATA 20,3A
02D3:  DATA E8,34
02D4:  DATA 20,37
02D5:  DATA E8,30
02D6:  DATA 6E,10
02D7:  DATA 43,10
02D8:  DATA E8,37
02D9:  DATA E1,31
02DA:  DATA A0,31
02DB:  DATA 00,01
02DC:  DATA D8,34
02DD:  DATA 6E,10
02DE:  DATA E3,30
02DF:  DATA 6D,10
02E0:  DATA 6F,37
02E1:  DATA 20,31
02E2:  DATA 61,37
02E3:  DATA 21,00
02E4:  DATA CB,22
02E5:  DATA 54,10
02E6:  DATA 54,24
02E7:  DATA D5,21
02E8:  DATA 00,00
02E9:  MOVF   0B,W
02EA:  MOVWF  55
02EB:  BCF    0B.7
02EC:  BSF    03.5
02ED:  BSF    03.6
02EE:  BSF    0C.7
02EF:  BSF    0C.0
02F0:  NOP
02F1:  NOP
02F2:  BCF    03.5
02F3:  BCF    03.6
02F4:  BTFSC  55.7
02F5:  BSF    0B.7
02F6:  BSF    03.6
02F7:  MOVF   0C,W
02F8:  ANDLW  7F
02F9:  BTFSC  03.2
02FA:  GOTO   33F
02FB:  BCF    03.6
02FC:  MOVWF  55
02FD:  BSF    03.6
02FE:  MOVF   0D,W
02FF:  BCF    03.6
0300:  MOVWF  56
0301:  BSF    03.6
0302:  MOVF   0F,W
0303:  BCF    03.6
0304:  MOVWF  57
0305:  MOVF   55,W
0306:  BTFSS  0C.4
0307:  GOTO   306
0308:  MOVWF  19
0309:  MOVF   56,W
030A:  BSF    03.6
030B:  MOVWF  0D
030C:  BCF    03.6
030D:  MOVF   57,W
030E:  BSF    03.6
030F:  MOVWF  0F
0310:  BCF    03.6
0311:  MOVF   0B,W
0312:  MOVWF  58
0313:  BCF    0B.7
0314:  BSF    03.5
0315:  BSF    03.6
0316:  BSF    0C.7
0317:  BSF    0C.0
0318:  NOP
0319:  NOP
031A:  BCF    03.5
031B:  BCF    03.6
031C:  BTFSC  58.7
031D:  BSF    0B.7
031E:  BSF    03.6
031F:  RLF    0C,W
0320:  RLF    0E,W
0321:  ANDLW  7F
0322:  BTFSC  03.2
0323:  GOTO   33F
0324:  BCF    03.6
0325:  MOVWF  55
0326:  BSF    03.6
0327:  MOVF   0D,W
0328:  BCF    03.6
0329:  MOVWF  56
032A:  BSF    03.6
032B:  MOVF   0F,W
032C:  BCF    03.6
032D:  MOVWF  57
032E:  MOVF   55,W
032F:  BTFSS  0C.4
0330:  GOTO   32F
0331:  MOVWF  19
0332:  MOVF   56,W
0333:  BSF    03.6
0334:  MOVWF  0D
0335:  BCF    03.6
0336:  MOVF   57,W
0337:  BSF    03.6
0338:  MOVWF  0F
0339:  INCF   0D,F
033A:  BTFSC  03.2
033B:  INCF   0F,F
033C:  BCF    03.6
033D:  GOTO   2E9
033E:  BSF    03.6
033F:  BCF    03.6
0340:  RETURN
*
0367:  MOVLW  20
0368:  MOVWF  6E
0369:  CLRF   6A
036A:  CLRF   6B
036B:  CLRF   6C
036C:  CLRF   6D
036D:  MOVF   65,W
036E:  MOVWF  7A
036F:  MOVF   64,W
0370:  MOVWF  79
0371:  MOVF   63,W
0372:  MOVWF  78
0373:  MOVF   62,W
0374:  MOVWF  77
0375:  BCF    03.0
0376:  BTFSS  77.0
0377:  GOTO   386
0378:  MOVF   66,W
0379:  ADDWF  6A,F
037A:  MOVF   67,W
037B:  BTFSC  03.0
037C:  INCFSZ 67,W
037D:  ADDWF  6B,F
037E:  MOVF   68,W
037F:  BTFSC  03.0
0380:  INCFSZ 68,W
0381:  ADDWF  6C,F
0382:  MOVF   69,W
0383:  BTFSC  03.0
0384:  INCFSZ 69,W
0385:  ADDWF  6D,F
0386:  RRF    6D,F
0387:  RRF    6C,F
0388:  RRF    6B,F
0389:  RRF    6A,F
038A:  RRF    7A,F
038B:  RRF    79,F
038C:  RRF    78,F
038D:  RRF    77,F
038E:  DECFSZ 6E,F
038F:  GOTO   375
0390:  RETURN
*
043F:  MOVF   0B,W
0440:  MOVWF  57
0441:  BCF    0B.7
0442:  BSF    03.5
0443:  BSF    03.6
0444:  BSF    0C.7
0445:  BSF    0C.0
0446:  NOP
0447:  NOP
0448:  BCF    03.5
0449:  BCF    03.6
044A:  BTFSC  57.7
044B:  BSF    0B.7
044C:  BTFSC  03.0
044D:  GOTO   477
044E:  BSF    03.6
044F:  MOVF   0C,W
0450:  ANDLW  7F
0451:  BCF    03.6
0452:  MOVWF  57
0453:  BSF    03.6
0454:  MOVF   0D,W
0455:  BCF    03.6
0456:  MOVWF  58
0457:  BSF    03.6
0458:  MOVF   0F,W
0459:  BCF    03.6
045A:  MOVWF  59
045B:  MOVF   57,W
045C:  BTFSS  0C.4
045D:  GOTO   45C
045E:  MOVWF  19
045F:  MOVF   58,W
0460:  BSF    03.6
0461:  MOVWF  0D
0462:  BCF    03.6
0463:  MOVF   59,W
0464:  BSF    03.6
0465:  MOVWF  0F
0466:  BCF    03.6
0467:  MOVF   0B,W
0468:  MOVWF  5A
0469:  BCF    0B.7
046A:  BSF    03.5
046B:  BSF    03.6
046C:  BSF    0C.7
046D:  BSF    0C.0
046E:  NOP
046F:  NOP
0470:  BCF    03.5
0471:  BCF    03.6
0472:  BTFSC  5A.7
0473:  BSF    0B.7
0474:  DECFSZ 56,F
0475:  GOTO   477
0476:  GOTO   497
0477:  BSF    03.6
0478:  RLF    0C,W
0479:  RLF    0E,W
047A:  ANDLW  7F
047B:  BCF    03.6
047C:  MOVWF  57
047D:  BSF    03.6
047E:  MOVF   0D,W
047F:  BCF    03.6
0480:  MOVWF  58
0481:  BSF    03.6
0482:  MOVF   0F,W
0483:  BCF    03.6
0484:  MOVWF  59
0485:  MOVF   57,W
0486:  BTFSS  0C.4
0487:  GOTO   486
0488:  MOVWF  19
0489:  MOVF   58,W
048A:  BSF    03.6
048B:  MOVWF  0D
048C:  BCF    03.6
048D:  MOVF   59,W
048E:  BSF    03.6
048F:  MOVWF  0F
0490:  INCF   0D,F
0491:  BTFSC  03.2
0492:  INCF   0F,F
0493:  BCF    03.0
0494:  BCF    03.6
0495:  DECFSZ 56,F
0496:  GOTO   43F
0497:  RETURN
0498:  BTFSC  03.1
0499:  GOTO   49D
049A:  MOVLW  6A
049B:  MOVWF  04
049C:  BCF    03.7
049D:  CLRF   77
049E:  CLRF   78
049F:  CLRF   79
04A0:  CLRF   7A
04A1:  CLRF   6A
04A2:  CLRF   6B
04A3:  CLRF   6C
04A4:  CLRF   6D
04A5:  MOVF   69,W
04A6:  IORWF  68,W
04A7:  IORWF  67,W
04A8:  IORWF  66,W
04A9:  BTFSC  03.2
04AA:  GOTO   4DB
04AB:  MOVLW  20
04AC:  MOVWF  6E
04AD:  BCF    03.0
04AE:  RLF    62,F
04AF:  RLF    63,F
04B0:  RLF    64,F
04B1:  RLF    65,F
04B2:  RLF    6A,F
04B3:  RLF    6B,F
04B4:  RLF    6C,F
04B5:  RLF    6D,F
04B6:  MOVF   69,W
04B7:  SUBWF  6D,W
04B8:  BTFSS  03.2
04B9:  GOTO   4C4
04BA:  MOVF   68,W
04BB:  SUBWF  6C,W
04BC:  BTFSS  03.2
04BD:  GOTO   4C4
04BE:  MOVF   67,W
04BF:  SUBWF  6B,W
04C0:  BTFSS  03.2
04C1:  GOTO   4C4
04C2:  MOVF   66,W
04C3:  SUBWF  6A,W
04C4:  BTFSS  03.0
04C5:  GOTO   4D5
04C6:  MOVF   66,W
04C7:  SUBWF  6A,F
04C8:  MOVF   67,W
04C9:  BTFSS  03.0
04CA:  INCFSZ 67,W
04CB:  SUBWF  6B,F
04CC:  MOVF   68,W
04CD:  BTFSS  03.0
04CE:  INCFSZ 68,W
04CF:  SUBWF  6C,F
04D0:  MOVF   69,W
04D1:  BTFSS  03.0
04D2:  INCFSZ 69,W
04D3:  SUBWF  6D,F
04D4:  BSF    03.0
04D5:  RLF    77,F
04D6:  RLF    78,F
04D7:  RLF    79,F
04D8:  RLF    7A,F
04D9:  DECFSZ 6E,F
04DA:  GOTO   4AD
04DB:  MOVF   6A,W
04DC:  MOVWF  00
04DD:  INCF   04,F
04DE:  MOVF   6B,W
04DF:  MOVWF  00
04E0:  INCF   04,F
04E1:  MOVF   6C,W
04E2:  MOVWF  00
04E3:  INCF   04,F
04E4:  MOVF   6D,W
04E5:  MOVWF  00
04E6:  RETURN
04E7:  MOVF   04,W
04E8:  MOVWF  5A
04E9:  BTFSS  59.7
04EA:  GOTO   4F8
04EB:  DECF   5A,F
04EC:  BSF    5A.5
04ED:  COMF   56,F
04EE:  COMF   57,F
04EF:  COMF   58,F
04F0:  COMF   59,F
04F1:  INCF   56,F
04F2:  BTFSC  03.2
04F3:  INCF   57,F
04F4:  BTFSC  03.2
04F5:  INCF   58,F
04F6:  BTFSC  03.2
04F7:  INCF   59,F
04F8:  MOVLW  3B
04F9:  MOVWF  61
04FA:  MOVLW  9A
04FB:  MOVWF  60
04FC:  MOVLW  CA
04FD:  MOVWF  5F
04FE:  CLRF   5E
04FF:  MOVLW  0A
0500:  MOVWF  5C
0501:  BSF    03.1
0502:  MOVLW  56
0503:  MOVWF  04
0504:  BCF    03.7
0505:  MOVF   59,W
0506:  MOVWF  65
0507:  MOVF   58,W
0508:  MOVWF  64
0509:  MOVF   57,W
050A:  MOVWF  63
050B:  MOVF   56,W
050C:  MOVWF  62
050D:  MOVF   61,W
050E:  MOVWF  69
050F:  MOVF   60,W
0510:  MOVWF  68
0511:  MOVF   5F,W
0512:  MOVWF  67
0513:  MOVF   5E,W
0514:  MOVWF  66
0515:  CALL   498
0516:  MOVF   78,W
0517:  MOVF   77,F
0518:  BTFSS  03.2
0519:  GOTO   52D
051A:  MOVF   5C,W
051B:  XORLW  01
051C:  BTFSC  03.2
051D:  GOTO   52D
051E:  MOVF   5A,W
051F:  BTFSC  03.2
0520:  GOTO   52F
0521:  ANDLW  0F
0522:  SUBWF  5C,W
0523:  BTFSC  03.2
0524:  GOTO   527
0525:  BTFSC  03.0
0526:  GOTO   54E
0527:  BTFSC  5A.7
0528:  GOTO   54E
0529:  BTFSC  5A.6
052A:  GOTO   52F
052B:  MOVLW  20
052C:  GOTO   549
052D:  MOVLW  20
052E:  ANDWF  5A,F
052F:  BTFSS  5A.5
0530:  GOTO   53B
0531:  BCF    5A.5
0532:  MOVF   77,W
0533:  MOVWF  5A
0534:  MOVLW  2D
0535:  BTFSS  0C.4
0536:  GOTO   535
0537:  MOVWF  19
0538:  MOVF   5A,W
0539:  MOVWF  77
053A:  CLRF   5A
053B:  MOVLW  30
053C:  BTFSS  5A.5
053D:  GOTO   549
053E:  BCF    5A.5
053F:  MOVF   77,W
0540:  MOVWF  5A
0541:  MOVLW  2D
0542:  BTFSS  0C.4
0543:  GOTO   542
0544:  MOVWF  19
0545:  MOVF   5A,W
0546:  MOVWF  77
0547:  CLRF   5A
0548:  MOVLW  30
0549:  ADDWF  77,F
054A:  MOVF   77,W
054B:  BTFSS  0C.4
054C:  GOTO   54B
054D:  MOVWF  19
054E:  BCF    03.1
054F:  MOVF   61,W
0550:  MOVWF  65
0551:  MOVF   60,W
0552:  MOVWF  64
0553:  MOVF   5F,W
0554:  MOVWF  63
0555:  MOVF   5E,W
0556:  MOVWF  62
0557:  CLRF   69
0558:  CLRF   68
0559:  CLRF   67
055A:  MOVLW  0A
055B:  MOVWF  66
055C:  CALL   498
055D:  MOVF   7A,W
055E:  MOVWF  61
055F:  MOVF   79,W
0560:  MOVWF  60
0561:  MOVF   78,W
0562:  MOVWF  5F
0563:  MOVF   77,W
0564:  MOVWF  5E
0565:  DECFSZ 5C,F
0566:  GOTO   501
0567:  RETURN
0568:  MOVLW  B6
0569:  MOVWF  77
056A:  CLRF   7A
056B:  CLRF   79
056C:  CLRF   78
056D:  BCF    56.0
056E:  BTFSS  55.7
056F:  GOTO   57E
0570:  BSF    56.0
0571:  COMF   52,F
0572:  COMF   53,F
0573:  COMF   54,F
0574:  COMF   55,F
0575:  INCF   52,F
0576:  BTFSS  03.2
0577:  GOTO   57E
0578:  INCF   53,F
0579:  BTFSS  03.2
057A:  GOTO   57E
057B:  INCF   54,F
057C:  BTFSC  03.2
057D:  INCF   55,F
057E:  MOVF   52,W
057F:  IORWF  53,W
0580:  IORWF  54,W
0581:  IORWF  55,W
0582:  BTFSS  03.2
0583:  GOTO   586
0584:  CLRF   77
0585:  GOTO   595
0586:  BCF    03.0
0587:  BTFSC  78.7
0588:  GOTO   592
0589:  RLF    52,F
058A:  RLF    53,F
058B:  RLF    54,F
058C:  RLF    55,F
058D:  RLF    7A,F
058E:  RLF    79,F
058F:  RLF    78,F
0590:  DECFSZ 77,F
0591:  GOTO   586
0592:  BCF    78.7
0593:  BTFSC  56.0
0594:  BSF    78.7
0595:  RETURN
0596:  MOVF   70,W
0597:  BTFSC  03.2
0598:  GOTO   668
0599:  BSF    03.5
059A:  MOVWF  24
059B:  MOVF   7B,W
059C:  BTFSS  03.2
059D:  GOTO   5A0
059E:  BCF    03.5
059F:  GOTO   668
05A0:  SUBWF  24,F
05A1:  BTFSS  03.0
05A2:  GOTO   5AA
05A3:  MOVLW  7F
05A4:  ADDWF  24,F
05A5:  BTFSS  03.0
05A6:  GOTO   5A9
05A7:  BCF    03.5
05A8:  GOTO   668
05A9:  GOTO   5B4
05AA:  MOVLW  81
05AB:  SUBWF  24,F
05AC:  BTFSC  03.0
05AD:  GOTO   5B0
05AE:  BCF    03.5
05AF:  GOTO   668
05B0:  BTFSS  03.2
05B1:  GOTO   5B4
05B2:  BCF    03.5
05B3:  GOTO   668
05B4:  MOVF   24,W
05B5:  MOVWF  77
05B6:  CLRF   78
05B7:  CLRF   79
05B8:  CLRF   7A
05B9:  CLRF   23
05BA:  MOVF   71,W
05BB:  MOVWF  22
05BC:  BSF    22.7
05BD:  MOVF   72,W
05BE:  MOVWF  21
05BF:  MOVF   73,W
05C0:  MOVWF  20
05C1:  MOVLW  19
05C2:  MOVWF  24
05C3:  MOVF   7E,W
05C4:  SUBWF  20,F
05C5:  BTFSC  03.0
05C6:  GOTO   5D7
05C7:  MOVLW  01
05C8:  SUBWF  21,F
05C9:  BTFSC  03.0
05CA:  GOTO   5D7
05CB:  SUBWF  22,F
05CC:  BTFSC  03.0
05CD:  GOTO   5D7
05CE:  SUBWF  23,F
05CF:  BTFSC  03.0
05D0:  GOTO   5D7
05D1:  INCF   23,F
05D2:  INCF   22,F
05D3:  INCF   21,F
05D4:  MOVF   7E,W
05D5:  ADDWF  20,F
05D6:  GOTO   609
05D7:  MOVF   7D,W
05D8:  SUBWF  21,F
05D9:  BTFSC  03.0
05DA:  GOTO   5F2
05DB:  MOVLW  01
05DC:  SUBWF  22,F
05DD:  BTFSC  03.0
05DE:  GOTO   5F2
05DF:  SUBWF  23,F
05E0:  BTFSC  03.0
05E1:  GOTO   5F2
05E2:  INCF   23,F
05E3:  INCF   22,F
05E4:  MOVF   7D,W
05E5:  ADDWF  21,F
05E6:  MOVF   7E,W
05E7:  ADDWF  20,F
05E8:  BTFSS  03.0
05E9:  GOTO   609
05EA:  INCF   21,F
05EB:  BTFSS  03.2
05EC:  GOTO   609
05ED:  INCF   22,F
05EE:  BTFSS  03.2
05EF:  GOTO   609
05F0:  INCF   23,F
05F1:  GOTO   609
05F2:  MOVF   7C,W
05F3:  IORLW  80
05F4:  SUBWF  22,F
05F5:  BTFSC  03.0
05F6:  GOTO   608
05F7:  MOVLW  01
05F8:  SUBWF  23,F
05F9:  BTFSC  03.0
05FA:  GOTO   608
05FB:  INCF   23,F
05FC:  MOVF   7C,W
05FD:  IORLW  80
05FE:  ADDWF  22,F
05FF:  MOVF   7D,W
0600:  ADDWF  21,F
0601:  BTFSS  03.0
0602:  GOTO   5E6
0603:  INCF   22,F
0604:  BTFSS  03.2
0605:  GOTO   5E6
0606:  INCF   23,F
0607:  GOTO   5E6
0608:  BSF    7A.0
0609:  DECFSZ 24,F
060A:  GOTO   60C
060B:  GOTO   617
060C:  BCF    03.0
060D:  RLF    20,F
060E:  RLF    21,F
060F:  RLF    22,F
0610:  RLF    23,F
0611:  BCF    03.0
0612:  RLF    7A,F
0613:  RLF    79,F
0614:  RLF    78,F
0615:  RLF    25,F
0616:  GOTO   5C3
0617:  BTFSS  25.0
0618:  GOTO   61F
0619:  BCF    03.0
061A:  RRF    78,F
061B:  RRF    79,F
061C:  RRF    7A,F
061D:  RRF    25,F
061E:  GOTO   623
061F:  DECFSZ 77,F
0620:  GOTO   623
0621:  BCF    03.5
0622:  GOTO   668
0623:  BTFSC  25.7
0624:  GOTO   64C
0625:  BCF    03.0
0626:  RLF    20,F
0627:  RLF    21,F
0628:  RLF    22,F
0629:  RLF    23,F
062A:  MOVF   7E,W
062B:  SUBWF  20,F
062C:  BTFSC  03.0
062D:  GOTO   638
062E:  MOVLW  01
062F:  SUBWF  21,F
0630:  BTFSC  03.0
0631:  GOTO   638
0632:  SUBWF  22,F
0633:  BTFSC  03.0
0634:  GOTO   638
0635:  SUBWF  23,F
0636:  BTFSS  03.0
0637:  GOTO   65D
0638:  MOVF   7D,W
0639:  SUBWF  21,F
063A:  BTFSC  03.0
063B:  GOTO   643
063C:  MOVLW  01
063D:  SUBWF  22,F
063E:  BTFSC  03.0
063F:  GOTO   643
0640:  SUBWF  23,F
0641:  BTFSS  03.0
0642:  GOTO   65D
0643:  MOVF   7C,W
0644:  IORLW  80
0645:  SUBWF  22,F
0646:  BTFSC  03.0
0647:  GOTO   64C
0648:  MOVLW  01
0649:  SUBWF  23,F
064A:  BTFSS  03.0
064B:  GOTO   65D
064C:  INCF   7A,F
064D:  BTFSS  03.2
064E:  GOTO   65D
064F:  INCF   79,F
0650:  BTFSS  03.2
0651:  GOTO   65D
0652:  INCF   78,F
0653:  BTFSS  03.2
0654:  GOTO   65D
0655:  INCF   77,F
0656:  BTFSS  03.2
0657:  GOTO   65A
0658:  BCF    03.5
0659:  GOTO   668
065A:  RRF    78,F
065B:  RRF    79,F
065C:  RRF    7A,F
065D:  MOVF   71,W
065E:  MOVWF  24
065F:  MOVF   7C,W
0660:  XORWF  24,F
0661:  BTFSS  24.7
0662:  GOTO   665
0663:  BSF    78.7
0664:  GOTO   66D
0665:  BCF    78.7
0666:  GOTO   66D
0667:  BCF    03.5
0668:  CLRF   77
0669:  CLRF   78
066A:  CLRF   79
066B:  CLRF   7A
066C:  BSF    03.5
066D:  BCF    03.5
066E:  RETURN
066F:  MOVF   5B,W
0670:  BTFSC  03.2
0671:  GOTO   6DF
0672:  MOVWF  63
0673:  MOVF   5F,W
0674:  BTFSC  03.2
0675:  GOTO   6DF
0676:  ADDWF  63,F
0677:  BTFSC  03.0
0678:  GOTO   680
0679:  MOVLW  7F
067A:  SUBWF  63,F
067B:  BTFSS  03.0
067C:  GOTO   6DF
067D:  BTFSC  03.2
067E:  GOTO   6DF
067F:  GOTO   684
0680:  MOVLW  81
0681:  ADDWF  63,F
0682:  BTFSC  03.0
0683:  GOTO   6DF
0684:  MOVF   63,W
0685:  MOVWF  77
0686:  CLRF   78
0687:  CLRF   79
0688:  CLRF   7A
0689:  MOVF   5C,W
068A:  MOVWF  67
068B:  BSF    67.7
068C:  MOVF   5D,W
068D:  MOVWF  66
068E:  MOVF   5E,W
068F:  MOVWF  65
0690:  MOVLW  18
0691:  MOVWF  63
0692:  CLRF   64
0693:  BTFSS  65.0
0694:  GOTO   6AD
0695:  MOVF   62,W
0696:  ADDWF  7A,F
0697:  BTFSS  03.0
0698:  GOTO   69F
0699:  INCF   79,F
069A:  BTFSS  03.2
069B:  GOTO   69F
069C:  INCF   78,F
069D:  BTFSC  03.2
069E:  BSF    64.7
069F:  MOVF   61,W
06A0:  ADDWF  79,F
06A1:  BTFSS  03.0
06A2:  GOTO   6A6
06A3:  INCF   78,F
06A4:  BTFSC  03.2
06A5:  BSF    64.7
06A6:  MOVF   60,W
06A7:  MOVWF  5D
06A8:  BSF    5D.7
06A9:  MOVF   5D,W
06AA:  ADDWF  78,F
06AB:  BTFSC  03.0
06AC:  BSF    64.7
06AD:  RLF    64,F
06AE:  RRF    78,F
06AF:  RRF    79,F
06B0:  RRF    7A,F
06B1:  RRF    67,F
06B2:  RRF    66,F
06B3:  RRF    65,F
06B4:  BCF    03.0
06B5:  DECFSZ 63,F
06B6:  GOTO   692
06B7:  MOVLW  01
06B8:  ADDWF  77,F
06B9:  BTFSC  03.0
06BA:  GOTO   6DF
06BB:  BTFSC  78.7
06BC:  GOTO   6C4
06BD:  RLF    67,F
06BE:  RLF    7A,F
06BF:  RLF    79,F
06C0:  RLF    78,F
06C1:  DECF   77,F
06C2:  BTFSC  03.2
06C3:  GOTO   6DF
06C4:  BTFSS  67.7
06C5:  GOTO   6D5
06C6:  INCF   7A,F
06C7:  BTFSS  03.2
06C8:  GOTO   6D5
06C9:  INCF   79,F
06CA:  BTFSS  03.2
06CB:  GOTO   6D5
06CC:  INCF   78,F
06CD:  BTFSS  03.2
06CE:  GOTO   6D5
06CF:  RRF    78,F
06D0:  RRF    79,F
06D1:  RRF    7A,F
06D2:  INCF   77,F
06D3:  BTFSC  03.2
06D4:  GOTO   6DF
06D5:  MOVF   5C,W
06D6:  MOVWF  64
06D7:  MOVF   60,W
06D8:  XORWF  64,F
06D9:  BTFSS  64.7
06DA:  GOTO   6DD
06DB:  BSF    78.7
06DC:  GOTO   6E3
06DD:  BCF    78.7
06DE:  GOTO   6E3
06DF:  CLRF   77
06E0:  CLRF   78
06E1:  CLRF   79
06E2:  CLRF   7A
06E3:  RETURN
06E4:  MOVF   04,W
06E5:  MOVWF  53
06E6:  MOVF   52,W
06E7:  MOVWF  55
06E8:  BTFSC  03.2
06E9:  GOTO   703
06EA:  MOVF   51,W
06EB:  MOVWF  5E
06EC:  MOVF   50,W
06ED:  MOVWF  5D
06EE:  MOVF   4F,W
06EF:  MOVWF  5C
06F0:  MOVF   4E,W
06F1:  MOVWF  5B
06F2:  CLRF   62
06F3:  CLRF   61
06F4:  MOVLW  20
06F5:  MOVWF  60
06F6:  MOVLW  82
06F7:  MOVWF  5F
06F8:  CALL   66F
06F9:  MOVF   7A,W
06FA:  MOVWF  51
06FB:  MOVF   79,W
06FC:  MOVWF  50
06FD:  MOVF   78,W
06FE:  MOVWF  4F
06FF:  MOVF   77,W
0700:  MOVWF  4E
0701:  DECFSZ 55,F
0702:  GOTO   6EA
0703:  MOVF   51,W
0704:  MOVWF  5E
0705:  MOVF   50,W
0706:  MOVWF  5D
0707:  MOVF   4F,W
0708:  MOVWF  5C
0709:  MOVF   4E,W
070A:  MOVWF  5B
070B:  MOVF   5B,W
070C:  SUBLW  B6
070D:  MOVWF  5B
070E:  CLRF   7A
070F:  MOVF   5C,W
0710:  MOVWF  5F
0711:  BSF    5C.7
0712:  BCF    03.0
0713:  RRF    5C,F
0714:  RRF    5D,F
0715:  RRF    5E,F
0716:  RRF    7A,F
0717:  RRF    79,F
0718:  RRF    78,F
0719:  RRF    77,F
071A:  DECFSZ 5B,F
071B:  GOTO   712
071C:  BTFSS  5F.7
071D:  GOTO   729
071E:  COMF   77,F
071F:  COMF   78,F
0720:  COMF   79,F
0721:  COMF   7A,F
0722:  INCF   77,F
0723:  BTFSC  03.2
0724:  INCF   78,F
0725:  BTFSC  03.2
0726:  INCF   79,F
0727:  BTFSC  03.2
0728:  INCF   7A,F
0729:  MOVF   7A,W
072A:  MOVWF  51
072B:  MOVF   79,W
072C:  MOVWF  50
072D:  MOVF   78,W
072E:  MOVWF  4F
072F:  MOVF   77,W
0730:  MOVWF  4E
0731:  BTFSS  51.7
0732:  GOTO   740
0733:  DECF   53,F
0734:  BSF    53.5
0735:  COMF   4E,F
0736:  COMF   4F,F
0737:  COMF   50,F
0738:  COMF   51,F
0739:  INCF   4E,F
073A:  BTFSC  03.2
073B:  INCF   4F,F
073C:  BTFSC  03.2
073D:  INCF   50,F
073E:  BTFSC  03.2
073F:  INCF   51,F
0740:  MOVLW  3B
0741:  MOVWF  5A
0742:  MOVLW  9A
0743:  MOVWF  59
0744:  MOVLW  CA
0745:  MOVWF  58
0746:  CLRF   57
0747:  MOVLW  0A
0748:  MOVWF  55
0749:  MOVF   52,W
074A:  BTFSC  03.2
074B:  INCF   53,F
074C:  BSF    03.1
074D:  MOVLW  4E
074E:  MOVWF  04
074F:  BCF    03.7
0750:  MOVF   51,W
0751:  MOVWF  65
0752:  MOVF   50,W
0753:  MOVWF  64
0754:  MOVF   4F,W
0755:  MOVWF  63
0756:  MOVF   4E,W
0757:  MOVWF  62
0758:  MOVF   5A,W
0759:  MOVWF  69
075A:  MOVF   59,W
075B:  MOVWF  68
075C:  MOVF   58,W
075D:  MOVWF  67
075E:  MOVF   57,W
075F:  MOVWF  66
0760:  CALL   498
0761:  MOVF   78,W
0762:  MOVF   77,F
0763:  BTFSS  03.2
0764:  GOTO   778
0765:  INCF   52,W
0766:  SUBWF  55,W
0767:  BTFSC  03.2
0768:  GOTO   778
0769:  MOVF   53,W
076A:  BTFSC  03.2
076B:  GOTO   77A
076C:  ANDLW  0F
076D:  SUBWF  55,W
076E:  BTFSC  03.2
076F:  GOTO   772
0770:  BTFSC  03.0
0771:  GOTO   7AE
0772:  BTFSC  53.7
0773:  GOTO   7AE
0774:  BTFSC  53.6
0775:  GOTO   77A
0776:  MOVLW  20
0777:  GOTO   7A9
0778:  MOVLW  20
0779:  ANDWF  53,F
077A:  BTFSS  53.5
077B:  GOTO   789
077C:  BCF    53.5
077D:  MOVF   52,W
077E:  BTFSS  03.2
077F:  DECF   53,F
0780:  MOVF   77,W
0781:  MOVWF  53
0782:  MOVLW  2D
0783:  BTFSS  0C.4
0784:  GOTO   783
0785:  MOVWF  19
0786:  MOVF   53,W
0787:  MOVWF  77
0788:  CLRF   53
0789:  MOVF   52,W
078A:  SUBWF  55,W
078B:  BTFSS  03.2
078C:  GOTO   798
078D:  MOVF   77,W
078E:  MOVWF  53
078F:  MOVLW  2E
0790:  BTFSS  0C.4
0791:  GOTO   790
0792:  MOVWF  19
0793:  MOVF   53,W
0794:  MOVWF  77
0795:  MOVLW  20
0796:  ANDWF  53,F
0797:  MOVLW  00
0798:  MOVLW  30
0799:  BTFSS  53.5
079A:  GOTO   7A9
079B:  BCF    53.5
079C:  MOVF   52,W
079D:  BTFSS  03.2
079E:  DECF   53,F
079F:  MOVF   77,W
07A0:  MOVWF  53
07A1:  MOVLW  2D
07A2:  BTFSS  0C.4
07A3:  GOTO   7A2
07A4:  MOVWF  19
07A5:  MOVF   53,W
07A6:  MOVWF  77
07A7:  CLRF   53
07A8:  MOVLW  30
07A9:  ADDWF  77,F
07AA:  MOVF   77,W
07AB:  BTFSS  0C.4
07AC:  GOTO   7AB
07AD:  MOVWF  19
07AE:  BCF    03.1
07AF:  MOVF   5A,W
07B0:  MOVWF  65
07B1:  MOVF   59,W
07B2:  MOVWF  64
07B3:  MOVF   58,W
07B4:  MOVWF  63
07B5:  MOVF   57,W
07B6:  MOVWF  62
07B7:  CLRF   69
07B8:  CLRF   68
07B9:  CLRF   67
07BA:  MOVLW  0A
07BB:  MOVWF  66
07BC:  CALL   498
07BD:  MOVF   7A,W
07BE:  MOVWF  5A
07BF:  MOVF   79,W
07C0:  MOVWF  59
07C1:  MOVF   78,W
07C2:  MOVWF  58
07C3:  MOVF   77,W
07C4:  MOVWF  57
07C5:  DECFSZ 55,F
07C6:  GOTO   74C
07C7:  RETURN
*
0800:  MOVLW  80
0801:  BTFSC  03.1
0802:  XORWF  7C,F
0803:  BSF    03.5
0804:  CLRF   22
0805:  CLRF   23
0806:  MOVF   71,W
0807:  MOVWF  21
0808:  MOVF   7C,W
0809:  XORWF  21,F
080A:  MOVF   70,W
080B:  BTFSC  03.2
080C:  GOTO   0F1
080D:  MOVWF  20
080E:  MOVWF  77
080F:  MOVF   7B,W
0810:  BTFSC  03.2
0811:  GOTO   0FA
0812:  SUBWF  20,F
0813:  BTFSC  03.2
0814:  GOTO   096
0815:  BTFSS  03.0
0816:  GOTO   054
0817:  MOVF   7C,W
0818:  MOVWF  26
0819:  BSF    26.7
081A:  MOVF   7D,W
081B:  MOVWF  25
081C:  MOVF   7E,W
081D:  MOVWF  24
081E:  CLRF   23
081F:  BCF    03.0
0820:  RRF    26,F
0821:  RRF    25,F
0822:  RRF    24,F
0823:  RRF    23,F
0824:  DECFSZ 20,F
0825:  GOTO   01E
0826:  BTFSS  21.7
0827:  GOTO   02B
0828:  BSF    22.0
0829:  GOTO   10E
082A:  BCF    22.0
082B:  BCF    20.0
082C:  BSF    22.4
082D:  MOVLW  73
082E:  MOVWF  04
082F:  BCF    03.7
0830:  GOTO   123
0831:  BCF    22.4
0832:  BTFSC  21.7
0833:  GOTO   03E
0834:  BTFSS  20.0
0835:  GOTO   049
0836:  RRF    26,F
0837:  RRF    25,F
0838:  RRF    24,F
0839:  RRF    23,F
083A:  INCF   77,F
083B:  BTFSC  03.2
083C:  GOTO   109
083D:  GOTO   049
083E:  BTFSC  26.7
083F:  GOTO   04C
0840:  BCF    03.0
0841:  RLF    23,F
0842:  RLF    24,F
0843:  RLF    25,F
0844:  RLF    26,F
0845:  DECF   77,F
0846:  BTFSC  03.2
0847:  GOTO   109
0848:  GOTO   03E
0849:  BSF    22.6
084A:  GOTO   0B6
084B:  BCF    22.6
084C:  MOVF   71,W
084D:  MOVWF  21
084E:  BTFSS  21.7
084F:  GOTO   052
0850:  BSF    26.7
0851:  GOTO   102
0852:  BCF    26.7
0853:  GOTO   102
0854:  MOVF   7B,W
0855:  MOVWF  20
0856:  MOVWF  77
0857:  MOVF   70,W
0858:  SUBWF  20,F
0859:  MOVF   71,W
085A:  MOVWF  26
085B:  BSF    26.7
085C:  MOVF   72,W
085D:  MOVWF  25
085E:  MOVF   73,W
085F:  MOVWF  24
0860:  CLRF   23
0861:  BCF    03.0
0862:  RRF    26,F
0863:  RRF    25,F
0864:  RRF    24,F
0865:  RRF    23,F
0866:  DECFSZ 20,F
0867:  GOTO   060
0868:  BTFSS  21.7
0869:  GOTO   06D
086A:  BSF    22.1
086B:  GOTO   10E
086C:  BCF    22.1
086D:  BCF    20.0
086E:  BSF    22.5
086F:  MOVLW  7E
0870:  MOVWF  04
0871:  BCF    03.7
0872:  GOTO   123
0873:  BCF    22.5
0874:  BTFSC  21.7
0875:  GOTO   080
0876:  BTFSS  20.0
0877:  GOTO   08B
0878:  RRF    26,F
0879:  RRF    25,F
087A:  RRF    24,F
087B:  RRF    23,F
087C:  INCF   77,F
087D:  BTFSC  03.2
087E:  GOTO   109
087F:  GOTO   08B
0880:  BTFSC  26.7
0881:  GOTO   08E
0882:  BCF    03.0
0883:  RLF    23,F
0884:  RLF    24,F
0885:  RLF    25,F
0886:  RLF    26,F
0887:  DECF   77,F
0888:  BTFSC  03.2
0889:  GOTO   109
088A:  GOTO   080
088B:  BSF    22.7
088C:  GOTO   0B6
088D:  BCF    22.7
088E:  MOVF   7C,W
088F:  MOVWF  21
0890:  BTFSS  21.7
0891:  GOTO   094
0892:  BSF    26.7
0893:  GOTO   102
0894:  BCF    26.7
0895:  GOTO   102
0896:  MOVF   7C,W
0897:  MOVWF  26
0898:  BSF    26.7
0899:  MOVF   7D,W
089A:  MOVWF  25
089B:  MOVF   7E,W
089C:  MOVWF  24
089D:  BTFSS  21.7
089E:  GOTO   0A3
089F:  BCF    26.7
08A0:  BSF    22.2
08A1:  GOTO   10E
08A2:  BCF    22.2
08A3:  CLRF   23
08A4:  BCF    20.0
08A5:  MOVLW  73
08A6:  MOVWF  04
08A7:  BCF    03.7
08A8:  GOTO   123
08A9:  BTFSC  21.7
08AA:  GOTO   0CC
08AB:  MOVF   71,W
08AC:  MOVWF  21
08AD:  BTFSS  20.0
08AE:  GOTO   0B6
08AF:  RRF    26,F
08B0:  RRF    25,F
08B1:  RRF    24,F
08B2:  RRF    23,F
08B3:  INCF   77,F
08B4:  BTFSC  03.2
08B5:  GOTO   109
08B6:  BTFSS  23.7
08B7:  GOTO   0C7
08B8:  INCF   24,F
08B9:  BTFSS  03.2
08BA:  GOTO   0C7
08BB:  INCF   25,F
08BC:  BTFSS  03.2
08BD:  GOTO   0C7
08BE:  INCF   26,F
08BF:  BTFSS  03.2
08C0:  GOTO   0C7
08C1:  RRF    26,F
08C2:  RRF    25,F
08C3:  RRF    24,F
08C4:  INCF   77,F
08C5:  BTFSC  03.2
08C6:  GOTO   109
08C7:  BTFSC  22.6
08C8:  GOTO   04B
08C9:  BTFSC  22.7
08CA:  GOTO   08D
08CB:  GOTO   0EB
08CC:  MOVLW  80
08CD:  XORWF  26,F
08CE:  BTFSS  26.7
08CF:  GOTO   0D4
08D0:  GOTO   10E
08D1:  MOVF   7C,W
08D2:  MOVWF  21
08D3:  GOTO   0E1
08D4:  MOVF   71,W
08D5:  MOVWF  21
08D6:  MOVF   26,F
08D7:  BTFSS  03.2
08D8:  GOTO   0E1
08D9:  MOVF   25,F
08DA:  BTFSS  03.2
08DB:  GOTO   0E1
08DC:  MOVF   24,F
08DD:  BTFSS  03.2
08DE:  GOTO   0E1
08DF:  CLRF   77
08E0:  GOTO   102
08E1:  BTFSC  26.7
08E2:  GOTO   0EB
08E3:  BCF    03.0
08E4:  RLF    23,F
08E5:  RLF    24,F
08E6:  RLF    25,F
08E7:  RLF    26,F
08E8:  DECFSZ 77,F
08E9:  GOTO   0E1
08EA:  GOTO   109
08EB:  BTFSS  21.7
08EC:  GOTO   0EF
08ED:  BSF    26.7
08EE:  GOTO   102
08EF:  BCF    26.7
08F0:  GOTO   102
08F1:  MOVF   7B,W
08F2:  MOVWF  77
08F3:  MOVF   7C,W
08F4:  MOVWF  26
08F5:  MOVF   7D,W
08F6:  MOVWF  25
08F7:  MOVF   7E,W
08F8:  MOVWF  24
08F9:  GOTO   102
08FA:  MOVF   70,W
08FB:  MOVWF  77
08FC:  MOVF   71,W
08FD:  MOVWF  26
08FE:  MOVF   72,W
08FF:  MOVWF  25
0900:  MOVF   73,W
0901:  MOVWF  24
0902:  MOVF   26,W
0903:  MOVWF  78
0904:  MOVF   25,W
0905:  MOVWF  79
0906:  MOVF   24,W
0907:  MOVWF  7A
0908:  GOTO   141
0909:  CLRF   77
090A:  CLRF   78
090B:  CLRF   79
090C:  CLRF   7A
090D:  GOTO   141
090E:  CLRF   23
090F:  COMF   24,F
0910:  COMF   25,F
0911:  COMF   26,F
0912:  COMF   23,F
0913:  INCF   23,F
0914:  BTFSS  03.2
0915:  GOTO   11C
0916:  INCF   24,F
0917:  BTFSS  03.2
0918:  GOTO   11C
0919:  INCF   25,F
091A:  BTFSC  03.2
091B:  INCF   26,F
091C:  BTFSC  22.0
091D:  GOTO   02A
091E:  BTFSC  22.1
091F:  GOTO   06C
0920:  BTFSC  22.2
0921:  GOTO   0A2
0922:  GOTO   0D1
0923:  MOVF   00,W
0924:  ADDWF  24,F
0925:  BTFSS  03.0
0926:  GOTO   12D
0927:  INCF   25,F
0928:  BTFSS  03.2
0929:  GOTO   12D
092A:  INCF   26,F
092B:  BTFSC  03.2
092C:  BSF    20.0
092D:  DECF   04,F
092E:  MOVF   00,W
092F:  ADDWF  25,F
0930:  BTFSS  03.0
0931:  GOTO   135
0932:  INCF   26,F
0933:  BTFSC  03.2
0934:  BSF    20.0
0935:  DECF   04,F
0936:  MOVF   00,W
0937:  BTFSS  00.7
0938:  XORLW  80
0939:  ADDWF  26,F
093A:  BTFSC  03.0
093B:  BSF    20.0
093C:  BTFSC  22.4
093D:  GOTO   031
093E:  BTFSC  22.5
093F:  GOTO   073
0940:  GOTO   0A9
0941:  BCF    03.5
0942:  RETURN
0943:  MOVF   71,W
0944:  MOVWF  74
0945:  MOVF   7C,W
0946:  XORWF  74,F
0947:  BTFSS  74.7
0948:  GOTO   14E
0949:  BCF    03.2
094A:  BCF    03.0
094B:  BTFSC  71.7
094C:  BSF    03.0
094D:  GOTO   181
094E:  MOVF   71,W
094F:  MOVWF  74
0950:  MOVF   7B,W
0951:  MOVWF  75
0952:  MOVF   70,W
0953:  SUBWF  75,F
0954:  BTFSC  03.2
0955:  GOTO   15C
0956:  BTFSS  74.7
0957:  GOTO   181
0958:  MOVF   03,W
0959:  XORLW  01
095A:  MOVWF  03
095B:  GOTO   181
095C:  MOVF   7C,W
095D:  MOVWF  75
095E:  MOVF   71,W
095F:  SUBWF  75,F
0960:  BTFSC  03.2
0961:  GOTO   168
0962:  BTFSS  74.7
0963:  GOTO   181
0964:  MOVF   03,W
0965:  XORLW  01
0966:  MOVWF  03
0967:  GOTO   181
0968:  MOVF   7D,W
0969:  MOVWF  75
096A:  MOVF   72,W
096B:  SUBWF  75,F
096C:  BTFSC  03.2
096D:  GOTO   174
096E:  BTFSS  74.7
096F:  GOTO   181
0970:  MOVF   03,W
0971:  XORLW  01
0972:  MOVWF  03
0973:  GOTO   181
0974:  MOVF   7E,W
0975:  MOVWF  75
0976:  MOVF   73,W
0977:  SUBWF  75,F
0978:  BTFSC  03.2
0979:  GOTO   180
097A:  BTFSS  74.7
097B:  GOTO   181
097C:  MOVF   03,W
097D:  XORLW  01
097E:  MOVWF  03
097F:  GOTO   181
0980:  BCF    03.0
0981:  RETURN
*
09C6:  MOVLW  B6
09C7:  MOVWF  77
09C8:  CLRF   7A
09C9:  CLRF   79
09CA:  CLRF   78
09CB:  MOVF   5E,W
09CC:  IORWF  5F,W
09CD:  IORWF  60,W
09CE:  IORWF  61,W
09CF:  BTFSS  03.2
09D0:  GOTO   1D3
09D1:  CLRF   77
09D2:  GOTO   1E0
09D3:  BCF    03.0
09D4:  BTFSC  78.7
09D5:  GOTO   1DF
09D6:  RLF    5E,F
09D7:  RLF    5F,F
09D8:  RLF    60,F
09D9:  RLF    61,F
09DA:  RLF    7A,F
09DB:  RLF    79,F
09DC:  RLF    78,F
09DD:  DECFSZ 77,F
09DE:  GOTO   1D3
09DF:  BCF    78.7
*
0F59:  BSF    0A.0
0F5A:  BSF    0A.1
0F5B:  BSF    0A.2
0F5C:  ADDWF  02,F
0F5D:  GOTO   419
0F5E:  GOTO   33F
0F5F:  GOTO   640
0F60:  GOTO   3AC
0F61:  GOTO   640
0F62:  GOTO   4D4
*
164C:  BTFSC  03.1
164D:  GOTO   651
164E:  MOVLW  4C
164F:  MOVWF  04
1650:  BCF    03.7
1651:  MOVF   47,W
1652:  XORWF  4B,W
1653:  ANDLW  80
1654:  MOVWF  51
1655:  BTFSS  47.7
1656:  GOTO   662
1657:  COMF   44,F
1658:  COMF   45,F
1659:  COMF   46,F
165A:  COMF   47,F
165B:  INCF   44,F
165C:  BTFSC  03.2
165D:  INCF   45,F
165E:  BTFSC  03.2
165F:  INCF   46,F
1660:  BTFSC  03.2
1661:  INCF   47,F
1662:  BTFSS  4B.7
1663:  GOTO   66F
1664:  COMF   48,F
1665:  COMF   49,F
1666:  COMF   4A,F
1667:  COMF   4B,F
1668:  INCF   48,F
1669:  BTFSC  03.2
166A:  INCF   49,F
166B:  BTFSC  03.2
166C:  INCF   4A,F
166D:  BTFSC  03.2
166E:  INCF   4B,F
166F:  CLRF   77
1670:  CLRF   78
1671:  CLRF   79
1672:  CLRF   7A
1673:  CLRF   4C
1674:  CLRF   4D
1675:  CLRF   4E
1676:  CLRF   4F
1677:  MOVF   4B,W
1678:  IORWF  4A,W
1679:  IORWF  49,W
167A:  IORWF  48,W
167B:  BTFSC  03.2
167C:  GOTO   6AD
167D:  MOVLW  20
167E:  MOVWF  50
167F:  BCF    03.0
1680:  RLF    44,F
1681:  RLF    45,F
1682:  RLF    46,F
1683:  RLF    47,F
1684:  RLF    4C,F
1685:  RLF    4D,F
1686:  RLF    4E,F
1687:  RLF    4F,F
1688:  MOVF   4B,W
1689:  SUBWF  4F,W
168A:  BTFSS  03.2
168B:  GOTO   696
168C:  MOVF   4A,W
168D:  SUBWF  4E,W
168E:  BTFSS  03.2
168F:  GOTO   696
1690:  MOVF   49,W
1691:  SUBWF  4D,W
1692:  BTFSS  03.2
1693:  GOTO   696
1694:  MOVF   48,W
1695:  SUBWF  4C,W
1696:  BTFSS  03.0
1697:  GOTO   6A7
1698:  MOVF   48,W
1699:  SUBWF  4C,F
169A:  MOVF   49,W
169B:  BTFSS  03.0
169C:  INCFSZ 49,W
169D:  SUBWF  4D,F
169E:  MOVF   4A,W
169F:  BTFSS  03.0
16A0:  INCFSZ 4A,W
16A1:  SUBWF  4E,F
16A2:  MOVF   4B,W
16A3:  BTFSS  03.0
16A4:  INCFSZ 4B,W
16A5:  SUBWF  4F,F
16A6:  BSF    03.0
16A7:  RLF    77,F
16A8:  RLF    78,F
16A9:  RLF    79,F
16AA:  RLF    7A,F
16AB:  DECFSZ 50,F
16AC:  GOTO   67F
16AD:  BTFSS  51.7
16AE:  GOTO   6BA
16AF:  COMF   77,F
16B0:  COMF   78,F
16B1:  COMF   79,F
16B2:  COMF   7A,F
16B3:  INCF   77,F
16B4:  BTFSC  03.2
16B5:  INCF   78,F
16B6:  BTFSC  03.2
16B7:  INCF   79,F
16B8:  BTFSC  03.2
16B9:  INCF   7A,F
16BA:  MOVF   4C,W
16BB:  MOVWF  00
16BC:  INCF   04,F
16BD:  MOVF   4D,W
16BE:  MOVWF  00
16BF:  INCF   04,F
16C0:  MOVF   4E,W
16C1:  MOVWF  00
16C2:  INCF   04,F
16C3:  MOVF   4F,W
16C4:  MOVWF  00
*
16D8:  MOVF   45,W
16D9:  CLRF   78
16DA:  SUBWF  44,W
16DB:  BTFSC  03.0
16DC:  GOTO   6E0
16DD:  MOVF   44,W
16DE:  MOVWF  77
16DF:  GOTO   6EC
16E0:  CLRF   77
16E1:  MOVLW  08
16E2:  MOVWF  46
16E3:  RLF    44,F
16E4:  RLF    77,F
16E5:  MOVF   45,W
16E6:  SUBWF  77,W
16E7:  BTFSC  03.0
16E8:  MOVWF  77
16E9:  RLF    78,F
16EA:  DECFSZ 46,F
16EB:  GOTO   6E3
....................  
.................... #list 
....................  
.................... #device ADC=16 
....................  
.................... #FUSES NOWDT                 	//No Watch Dog Timer 
.................... #FUSES NOBROWNOUT            	//No brownout reset 
.................... #FUSES NOLVP                 	//No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
....................  
.................... #use delay(crystal=20000000) 
....................  
....................  
.................... #define ENTER 13 
.................... #define plus '+' 
.................... #define minus '-' 
.................... #define multiply '*' 
.................... #define divide '/' 
.................... #define remainder '%' 
.................... #define exponent '^' 
.................... #define factorial '!' 
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
*
0F90:  BCF    03.5
0F91:  CLRF   20
0F92:  CLRF   21
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
*
09F0:  MOVF   65,W
09F1:  MOVWF  73
09F2:  MOVF   64,W
09F3:  MOVWF  72
09F4:  MOVF   63,W
09F5:  MOVWF  71
09F6:  MOVF   62,W
09F7:  MOVWF  70
09F8:  CLRF   7E
09F9:  CLRF   7D
09FA:  CLRF   7C
09FB:  CLRF   7B
09FC:  CALL   143
09FD:  BTFSC  03.0
09FE:  GOTO   201
09FF:  BTFSS  03.2
0A00:  GOTO   206
....................       return(0.0); 
0A01:  CLRF   77
0A02:  CLRF   78
0A03:  CLRF   79
0A04:  CLRF   7A
0A05:  GOTO   280
....................  
....................    y=x; 
0A06:  MOVF   65,W
0A07:  MOVWF  69
0A08:  MOVF   64,W
0A09:  MOVWF  68
0A0A:  MOVF   63,W
0A0B:  MOVWF  67
0A0C:  MOVF   62,W
0A0D:  MOVWF  66
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
0A0E:  CLRF   6F
0A0F:  MOVLW  66
0A10:  MOVWF  6E
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
0A11:  MOVF   6E,W
0A12:  MOVWF  04
0A13:  BCF    03.7
0A14:  BTFSC  6F.0
0A15:  BSF    03.7
0A16:  MOVF   00,W
0A17:  CLRF   73
0A18:  MOVWF  72
0A19:  MOVLW  7F
0A1A:  ADDWF  72,F
0A1B:  BTFSC  03.0
0A1C:  INCF   73,F
0A1D:  BCF    03.0
0A1E:  RRF    73,W
0A1F:  MOVWF  7A
0A20:  RRF    72,W
0A21:  MOVWF  79
0A22:  MOVWF  72
0A23:  MOVF   6E,W
0A24:  MOVWF  04
0A25:  BCF    03.7
0A26:  BTFSC  6F.0
0A27:  BSF    03.7
0A28:  MOVF   72,W
0A29:  MOVWF  00
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
0A2A:  MOVF   69,W
0A2B:  MOVWF  6D
0A2C:  MOVF   68,W
0A2D:  MOVWF  6C
0A2E:  MOVF   67,W
0A2F:  MOVWF  6B
0A30:  MOVF   66,W
0A31:  MOVWF  6A
....................       y+=(x/y); 
0A32:  MOVF   65,W
0A33:  MOVWF  73
0A34:  MOVF   64,W
0A35:  MOVWF  72
0A36:  MOVF   63,W
0A37:  MOVWF  71
0A38:  MOVF   62,W
0A39:  MOVWF  70
0A3A:  MOVF   69,W
0A3B:  MOVWF  7E
0A3C:  MOVF   68,W
0A3D:  MOVWF  7D
0A3E:  MOVF   67,W
0A3F:  MOVWF  7C
0A40:  MOVF   66,W
0A41:  MOVWF  7B
0A42:  BCF    0A.3
0A43:  CALL   596
0A44:  BSF    0A.3
0A45:  BCF    03.1
0A46:  MOVF   69,W
0A47:  MOVWF  73
0A48:  MOVF   68,W
0A49:  MOVWF  72
0A4A:  MOVF   67,W
0A4B:  MOVWF  71
0A4C:  MOVF   66,W
0A4D:  MOVWF  70
0A4E:  MOVF   7A,W
0A4F:  MOVWF  7E
0A50:  MOVF   79,W
0A51:  MOVWF  7D
0A52:  MOVF   78,W
0A53:  MOVWF  7C
0A54:  MOVF   77,W
0A55:  MOVWF  7B
0A56:  CALL   000
0A57:  MOVF   7A,W
0A58:  MOVWF  69
0A59:  MOVF   79,W
0A5A:  MOVWF  68
0A5B:  MOVF   78,W
0A5C:  MOVWF  67
0A5D:  MOVF   77,W
0A5E:  MOVWF  66
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
0A5F:  MOVF   6E,W
0A60:  MOVWF  04
0A61:  BCF    03.7
0A62:  BTFSC  6F.0
0A63:  BSF    03.7
0A64:  DECF   00,F
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
0A65:  MOVF   6D,W
0A66:  MOVWF  73
0A67:  MOVF   6C,W
0A68:  MOVWF  72
0A69:  MOVF   6B,W
0A6A:  MOVWF  71
0A6B:  MOVF   6A,W
0A6C:  MOVWF  70
0A6D:  MOVF   69,W
0A6E:  MOVWF  7E
0A6F:  MOVF   68,W
0A70:  MOVWF  7D
0A71:  MOVF   67,W
0A72:  MOVWF  7C
0A73:  MOVF   66,W
0A74:  MOVWF  7B
0A75:  CALL   143
0A76:  BTFSS  03.2
0A77:  GOTO   22A
....................  
....................    return(res); 
0A78:  MOVF   6A,W
0A79:  MOVWF  77
0A7A:  MOVF   6B,W
0A7B:  MOVWF  78
0A7C:  MOVF   6C,W
0A7D:  MOVWF  79
0A7E:  MOVF   6D,W
0A7F:  MOVWF  7A
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include <mienthuc.c> 
.................... #use delay(clock=20M) 
.................... #use rs232(baud=9600,xmit=PIN_C6,rcv=PIN_C7) 
.................... signed long long power(signed long long a,signed long long b) { 
*
14D5:  CLRF   4F
14D6:  CLRF   4E
14D7:  CLRF   4D
14D8:  MOVLW  01
14D9:  MOVWF  4C
....................     long long result = 1; 
....................     for(int i = 1; i <= b; i++) { 
14DA:  MOVWF  50
14DB:  BTFSC  4B.7
14DC:  GOTO   507
14DD:  MOVF   4B,F
14DE:  BTFSS  03.2
14DF:  GOTO   4EA
14E0:  MOVF   4A,F
14E1:  BTFSS  03.2
14E2:  GOTO   4EA
14E3:  MOVF   49,F
14E4:  BTFSS  03.2
14E5:  GOTO   4EA
14E6:  MOVF   50,W
14E7:  SUBWF  48,W
14E8:  BTFSS  03.0
14E9:  GOTO   507
....................         result *= a; 
14EA:  MOVF   4F,W
14EB:  MOVWF  65
14EC:  MOVF   4E,W
14ED:  MOVWF  64
14EE:  MOVF   4D,W
14EF:  MOVWF  63
14F0:  MOVF   4C,W
14F1:  MOVWF  62
14F2:  MOVF   47,W
14F3:  MOVWF  69
14F4:  MOVF   46,W
14F5:  MOVWF  68
14F6:  MOVF   45,W
14F7:  MOVWF  67
14F8:  MOVF   44,W
14F9:  MOVWF  66
14FA:  BCF    0A.4
14FB:  CALL   367
14FC:  BSF    0A.4
14FD:  MOVF   7A,W
14FE:  MOVWF  4F
14FF:  MOVF   79,W
1500:  MOVWF  4E
1501:  MOVF   78,W
1502:  MOVWF  4D
1503:  MOVF   77,W
1504:  MOVWF  4C
1505:  INCF   50,F
1506:  GOTO   4DB
....................     } 
....................     return result; 
1507:  MOVF   4C,W
1508:  MOVWF  77
1509:  MOVF   4D,W
150A:  MOVWF  78
150B:  MOVF   4E,W
150C:  MOVWF  79
150D:  MOVF   4F,W
150E:  MOVWF  7A
....................  } 
.................... void loiSyntax() 
.................... { 
....................     printf("Loi SYNTAX");putc(13); 
*
0355:  MOVLW  04
0356:  BSF    03.6
0357:  MOVWF  0D
0358:  MOVLW  00
0359:  MOVWF  0F
035A:  BCF    03.6
035B:  CALL   2E9
035C:  MOVLW  0D
035D:  BTFSS  0C.4
035E:  GOTO   35D
035F:  MOVWF  19
....................     output_high(PIN_C0); 
0360:  BCF    22.0
0361:  MOVF   22,W
0362:  BSF    03.5
0363:  MOVWF  07
0364:  BCF    03.5
0365:  BSF    07.0
0366:  RETURN
.................... } 
.................... signed long long nhap_so() 
.................... { 
....................    nhapso:  
....................     char n=0 ,k=0; 
....................     signed long long t=0; 
*
0391:  CLRF   4E
0392:  CLRF   4F
0393:  CLRF   53
0394:  CLRF   52
0395:  CLRF   51
0396:  CLRF   50
....................     for (int i=0;;i++) 
0397:  CLRF   54
....................     { 
....................      n = getc(); 
0398:  BTFSS  0C.5
0399:  GOTO   398
039A:  MOVF   1A,W
039B:  MOVWF  4E
....................      if ( n >= '0' && n <= '9' || n == minus || n == ENTER) { 
039C:  MOVF   4E,W
039D:  SUBLW  2F
039E:  BTFSC  03.0
039F:  GOTO   3A4
03A0:  MOVF   4E,W
03A1:  SUBLW  39
03A2:  BTFSC  03.0
03A3:  GOTO   3AC
03A4:  MOVF   4E,W
03A5:  SUBLW  2D
03A6:  BTFSC  03.2
03A7:  GOTO   3AC
03A8:  MOVF   4E,W
03A9:  SUBLW  0D
03AA:  BTFSS  03.2
03AB:  GOTO   42C
....................      if (n == minus){i = i - 1;k=n;printf("-");} 
03AC:  MOVF   4E,W
03AD:  SUBLW  2D
03AE:  BTFSS  03.2
03AF:  GOTO   3B9
03B0:  MOVLW  01
03B1:  SUBWF  54,F
03B2:  MOVF   4E,W
03B3:  MOVWF  4F
03B4:  MOVLW  2D
03B5:  BTFSS  0C.4
03B6:  GOTO   3B5
03B7:  MOVWF  19
03B8:  GOTO   42B
....................      else if (n == ENTER){putc(13);return t;break;} 
03B9:  MOVF   4E,W
03BA:  SUBLW  0D
03BB:  BTFSS  03.2
03BC:  GOTO   3CC
03BD:  MOVLW  0D
03BE:  BTFSS  0C.4
03BF:  GOTO   3BE
03C0:  MOVWF  19
03C1:  MOVF   50,W
03C2:  MOVWF  77
03C3:  MOVF   51,W
03C4:  MOVWF  78
03C5:  MOVF   52,W
03C6:  MOVWF  79
03C7:  MOVF   53,W
03C8:  MOVWF  7A
03C9:  GOTO   43E
03CA:  GOTO   43A
03CB:  GOTO   42B
....................      else 
....................      {if(k == minus){printf("%c",n);n = n - 0x30;t = t*10 - n;} 
03CC:  MOVF   4F,W
03CD:  SUBLW  2D
03CE:  BTFSS  03.2
03CF:  GOTO   402
03D0:  MOVF   4E,W
03D1:  BTFSS  0C.4
03D2:  GOTO   3D1
03D3:  MOVWF  19
03D4:  MOVLW  30
03D5:  SUBWF  4E,F
03D6:  MOVF   53,W
03D7:  MOVWF  65
03D8:  MOVF   52,W
03D9:  MOVWF  64
03DA:  MOVF   51,W
03DB:  MOVWF  63
03DC:  MOVF   50,W
03DD:  MOVWF  62
03DE:  CLRF   69
03DF:  CLRF   68
03E0:  CLRF   67
03E1:  MOVLW  0A
03E2:  MOVWF  66
03E3:  CALL   367
03E4:  MOVF   7A,W
03E5:  MOVWF  58
03E6:  MOVF   79,W
03E7:  MOVWF  57
03E8:  MOVF   78,W
03E9:  MOVWF  56
03EA:  MOVF   77,W
03EB:  MOVWF  55
03EC:  MOVF   4E,W
03ED:  SUBWF  55,W
03EE:  MOVWF  50
03EF:  MOVF   56,W
03F0:  MOVWF  51
03F1:  MOVLW  00
03F2:  BTFSS  03.0
03F3:  MOVLW  01
03F4:  SUBWF  51,F
03F5:  MOVF   57,W
03F6:  MOVWF  52
03F7:  MOVLW  00
03F8:  BTFSS  03.0
03F9:  MOVLW  01
03FA:  SUBWF  52,F
03FB:  MOVF   58,W
03FC:  MOVWF  53
03FD:  MOVLW  00
03FE:  BTFSS  03.0
03FF:  MOVLW  01
0400:  SUBWF  53,F
0401:  GOTO   42B
....................       else{printf("%c",n);n = n - 0x30;t = t*10 + n;} 
0402:  MOVF   4E,W
0403:  BTFSS  0C.4
0404:  GOTO   403
0405:  MOVWF  19
0406:  MOVLW  30
0407:  SUBWF  4E,F
0408:  MOVF   53,W
0409:  MOVWF  65
040A:  MOVF   52,W
040B:  MOVWF  64
040C:  MOVF   51,W
040D:  MOVWF  63
040E:  MOVF   50,W
040F:  MOVWF  62
0410:  CLRF   69
0411:  CLRF   68
0412:  CLRF   67
0413:  MOVLW  0A
0414:  MOVWF  66
0415:  CALL   367
0416:  MOVF   4E,W
0417:  ADDWF  77,W
0418:  MOVWF  50
0419:  MOVF   78,W
041A:  MOVWF  51
041B:  MOVLW  00
041C:  BTFSC  03.0
041D:  MOVLW  01
041E:  ADDWF  51,F
041F:  MOVF   79,W
0420:  MOVWF  52
0421:  MOVLW  00
0422:  BTFSC  03.0
0423:  MOVLW  01
0424:  ADDWF  52,F
0425:  MOVF   7A,W
0426:  MOVWF  53
0427:  MOVLW  00
0428:  BTFSC  03.0
0429:  MOVLW  01
042A:  ADDWF  53,F
....................      }} 
042B:  GOTO   438
....................      else {printf("Chi nhap ki tu so, moi nhap lai");putc(13);goto nhapso;} 
042C:  MOVLW  0A
042D:  BSF    03.6
042E:  MOVWF  0D
042F:  MOVLW  00
0430:  MOVWF  0F
0431:  BCF    03.6
0432:  CALL   2E9
0433:  MOVLW  0D
0434:  BTFSS  0C.4
0435:  GOTO   434
0436:  MOVWF  19
0437:  GOTO   391
0438:  INCF   54,F
0439:  GOTO   398
....................     } 
....................     putc(13); 
043A:  MOVLW  0D
043B:  BTFSS  0C.4
043C:  GOTO   43B
043D:  MOVWF  19
043E:  RETURN
.................... } 
.................... void mienthuc(){ 
....................    printf("Phep toan don gian: nhan T hoac t");putc(13); 
*
10F1:  MOVLW  1A
10F2:  BSF    03.6
10F3:  MOVWF  0D
10F4:  MOVLW  00
10F5:  MOVWF  0F
10F6:  BCF    0A.4
10F7:  BCF    03.6
10F8:  CALL   2E9
10F9:  BSF    0A.4
10FA:  MOVLW  0D
10FB:  BTFSS  0C.4
10FC:  GOTO   0FB
10FD:  MOVWF  19
....................    printf("Giai phuong trinh bac 1: nhan P hoac p");putc(13); 
10FE:  MOVLW  2B
10FF:  BSF    03.6
1100:  MOVWF  0D
1101:  MOVLW  00
1102:  MOVWF  0F
1103:  BCF    0A.4
1104:  BCF    03.6
1105:  CALL   2E9
1106:  BSF    0A.4
1107:  MOVLW  0D
1108:  BTFSS  0C.4
1109:  GOTO   108
110A:  MOVWF  19
....................    printf("Tinh so mu a^b: nhan M hoac m");putc(13); 
110B:  MOVLW  3F
110C:  BSF    03.6
110D:  MOVWF  0D
110E:  MOVLW  00
110F:  MOVWF  0F
1110:  BCF    0A.4
1111:  BCF    03.6
1112:  CALL   2E9
1113:  BSF    0A.4
1114:  MOVLW  0D
1115:  BTFSS  0C.4
1116:  GOTO   115
1117:  MOVWF  19
....................    printf("Tri tuyet doi: nhan D hoac d");putc(13); 
1118:  MOVLW  4E
1119:  BSF    03.6
111A:  MOVWF  0D
111B:  MOVLW  00
111C:  MOVWF  0F
111D:  BCF    0A.4
111E:  BCF    03.6
111F:  CALL   2E9
1120:  BSF    0A.4
1121:  MOVLW  0D
1122:  BTFSS  0C.4
1123:  GOTO   122
1124:  MOVWF  19
....................    printf("Kiem tra so nguyen to nhan N hoac n");putc(13); 
1125:  MOVLW  5D
1126:  BSF    03.6
1127:  MOVWF  0D
1128:  MOVLW  00
1129:  MOVWF  0F
112A:  BCF    0A.4
112B:  BCF    03.6
112C:  CALL   2E9
112D:  BSF    0A.4
112E:  MOVLW  0D
112F:  BTFSS  0C.4
1130:  GOTO   12F
1131:  MOVWF  19
....................    char cn1; 
....................    signed long long a=0,b=0,c=0; 
....................    float a1,b1,c1,x; 
1132:  CLRF   29
1133:  CLRF   28
1134:  CLRF   27
1135:  CLRF   26
1136:  CLRF   2D
1137:  CLRF   2C
1138:  CLRF   2B
1139:  CLRF   2A
113A:  CLRF   31
113B:  CLRF   30
113C:  CLRF   2F
113D:  CLRF   2E
....................    cn1 = getc(); 
113E:  BTFSS  0C.5
113F:  GOTO   13E
1140:  MOVF   1A,W
1141:  MOVWF  25
....................    if (cn1 == 'T' || cn1 == 't') 
1142:  MOVF   25,W
1143:  SUBLW  54
1144:  BTFSC  03.2
1145:  GOTO   14A
1146:  MOVF   25,W
1147:  SUBLW  74
1148:  BTFSS  03.2
1149:  GOTO   395
....................    { 
....................    printf("Phep tinh don gian");putc(13); 
114A:  MOVLW  6F
114B:  BSF    03.6
114C:  MOVWF  0D
114D:  MOVLW  00
114E:  MOVWF  0F
114F:  BCF    0A.4
1150:  BCF    03.6
1151:  CALL   2E9
1152:  BSF    0A.4
1153:  MOVLW  0D
1154:  BTFSS  0C.4
1155:  GOTO   154
1156:  MOVWF  19
....................    printf("Nhap a: "); 
1157:  MOVLW  79
1158:  BSF    03.6
1159:  MOVWF  0D
115A:  MOVLW  00
115B:  MOVWF  0F
115C:  BCF    0A.4
115D:  BCF    03.6
115E:  CALL   2E9
115F:  BSF    0A.4
....................    a = nhap_so(); 
1160:  BCF    0A.4
1161:  CALL   391
1162:  BSF    0A.4
1163:  MOVF   7A,W
1164:  MOVWF  29
1165:  MOVF   79,W
1166:  MOVWF  28
1167:  MOVF   78,W
1168:  MOVWF  27
1169:  MOVF   77,W
116A:  MOVWF  26
....................    printf("Nhap b: "); 
116B:  MOVLW  7E
116C:  BSF    03.6
116D:  MOVWF  0D
116E:  MOVLW  00
116F:  MOVWF  0F
1170:  BCF    0A.4
1171:  BCF    03.6
1172:  CALL   2E9
1173:  BSF    0A.4
....................    b = nhap_so(); 
1174:  BCF    0A.4
1175:  CALL   391
1176:  BSF    0A.4
1177:  MOVF   7A,W
1178:  MOVWF  2D
1179:  MOVF   79,W
117A:  MOVWF  2C
117B:  MOVF   78,W
117C:  MOVWF  2B
117D:  MOVF   77,W
117E:  MOVWF  2A
....................    printf("Nhap phep tinh: "); 
117F:  MOVLW  83
1180:  BSF    03.6
1181:  MOVWF  0D
1182:  MOVLW  00
1183:  MOVWF  0F
1184:  BCF    0A.4
1185:  BCF    03.6
1186:  CALL   2E9
1187:  BSF    0A.4
....................    switch(getc()) 
1188:  BTFSS  0C.5
1189:  GOTO   188
118A:  MOVF   1A,W
118B:  XORLW  2B
118C:  BTFSC  03.2
118D:  GOTO   198
118E:  XORLW  06
118F:  BTFSC  03.2
1190:  GOTO   205
1191:  XORLW  07
1192:  BTFSC  03.2
1193:  GOTO   272
1194:  XORLW  05
1195:  BTFSC  03.2
1196:  GOTO   2E5
1197:  GOTO   390
....................    { 
....................    case plus: printf("+");putc(13);printf("Ket qua %ld + %ld = %ld",a,b,a+b);putc(13); break; 
1198:  MOVLW  2B
1199:  BTFSS  0C.4
119A:  GOTO   199
119B:  MOVWF  19
119C:  MOVLW  0D
119D:  BTFSS  0C.4
119E:  GOTO   19D
119F:  MOVWF  19
11A0:  MOVF   2A,W
11A1:  ADDWF  26,W
11A2:  MOVWF  44
11A3:  MOVF   27,W
11A4:  MOVWF  45
11A5:  MOVF   2B,W
11A6:  BTFSC  03.0
11A7:  INCFSZ 2B,W
11A8:  ADDWF  45,F
11A9:  MOVF   28,W
11AA:  MOVWF  46
11AB:  MOVF   2C,W
11AC:  BTFSC  03.0
11AD:  INCFSZ 2C,W
11AE:  ADDWF  46,F
11AF:  MOVF   29,W
11B0:  MOVWF  47
11B1:  MOVF   2D,W
11B2:  BTFSC  03.0
11B3:  INCFSZ 2D,W
11B4:  ADDWF  47,F
11B5:  MOVLW  8C
11B6:  BSF    03.6
11B7:  MOVWF  0D
11B8:  MOVLW  00
11B9:  MOVWF  0F
11BA:  BCF    03.0
11BB:  MOVLW  08
11BC:  BCF    03.6
11BD:  MOVWF  56
11BE:  BCF    0A.4
11BF:  CALL   43F
11C0:  BSF    0A.4
11C1:  MOVLW  41
11C2:  MOVWF  04
11C3:  MOVF   29,W
11C4:  MOVWF  59
11C5:  MOVF   28,W
11C6:  MOVWF  58
11C7:  MOVF   27,W
11C8:  MOVWF  57
11C9:  MOVF   26,W
11CA:  MOVWF  56
11CB:  BCF    0A.4
11CC:  CALL   4E7
11CD:  BSF    0A.4
11CE:  MOVLW  20
11CF:  BTFSS  0C.4
11D0:  GOTO   1CF
11D1:  MOVWF  19
11D2:  MOVLW  2B
11D3:  BTFSS  0C.4
11D4:  GOTO   1D3
11D5:  MOVWF  19
11D6:  MOVLW  20
11D7:  BTFSS  0C.4
11D8:  GOTO   1D7
11D9:  MOVWF  19
11DA:  MOVLW  41
11DB:  MOVWF  04
11DC:  MOVF   2D,W
11DD:  MOVWF  59
11DE:  MOVF   2C,W
11DF:  MOVWF  58
11E0:  MOVF   2B,W
11E1:  MOVWF  57
11E2:  MOVF   2A,W
11E3:  MOVWF  56
11E4:  BCF    0A.4
11E5:  CALL   4E7
11E6:  BSF    0A.4
11E7:  MOVLW  20
11E8:  BTFSS  0C.4
11E9:  GOTO   1E8
11EA:  MOVWF  19
11EB:  MOVLW  3D
11EC:  BTFSS  0C.4
11ED:  GOTO   1EC
11EE:  MOVWF  19
11EF:  MOVLW  20
11F0:  BTFSS  0C.4
11F1:  GOTO   1F0
11F2:  MOVWF  19
11F3:  MOVLW  41
11F4:  MOVWF  04
11F5:  MOVF   47,W
11F6:  MOVWF  59
11F7:  MOVF   46,W
11F8:  MOVWF  58
11F9:  MOVF   45,W
11FA:  MOVWF  57
11FB:  MOVF   44,W
11FC:  MOVWF  56
11FD:  BCF    0A.4
11FE:  CALL   4E7
11FF:  BSF    0A.4
1200:  MOVLW  0D
1201:  BTFSS  0C.4
1202:  GOTO   201
1203:  MOVWF  19
1204:  GOTO   394
....................    case minus: printf("-");putc(13);printf("Ket qua %ld - %ld = %ld",a,b,a-b);putc(13); break; 
1205:  MOVLW  2D
1206:  BTFSS  0C.4
1207:  GOTO   206
1208:  MOVWF  19
1209:  MOVLW  0D
120A:  BTFSS  0C.4
120B:  GOTO   20A
120C:  MOVWF  19
120D:  MOVF   2A,W
120E:  SUBWF  26,W
120F:  MOVWF  44
1210:  MOVF   27,W
1211:  MOVWF  45
1212:  MOVF   2B,W
1213:  BTFSS  03.0
1214:  INCFSZ 2B,W
1215:  SUBWF  45,F
1216:  MOVF   28,W
1217:  MOVWF  46
1218:  MOVF   2C,W
1219:  BTFSS  03.0
121A:  INCFSZ 2C,W
121B:  SUBWF  46,F
121C:  MOVF   29,W
121D:  MOVWF  47
121E:  MOVF   2D,W
121F:  BTFSS  03.0
1220:  INCFSZ 2D,W
1221:  SUBWF  47,F
1222:  MOVLW  98
1223:  BSF    03.6
1224:  MOVWF  0D
1225:  MOVLW  00
1226:  MOVWF  0F
1227:  BCF    03.0
1228:  MOVLW  08
1229:  BCF    03.6
122A:  MOVWF  56
122B:  BCF    0A.4
122C:  CALL   43F
122D:  BSF    0A.4
122E:  MOVLW  41
122F:  MOVWF  04
1230:  MOVF   29,W
1231:  MOVWF  59
1232:  MOVF   28,W
1233:  MOVWF  58
1234:  MOVF   27,W
1235:  MOVWF  57
1236:  MOVF   26,W
1237:  MOVWF  56
1238:  BCF    0A.4
1239:  CALL   4E7
123A:  BSF    0A.4
123B:  MOVLW  20
123C:  BTFSS  0C.4
123D:  GOTO   23C
123E:  MOVWF  19
123F:  MOVLW  2D
1240:  BTFSS  0C.4
1241:  GOTO   240
1242:  MOVWF  19
1243:  MOVLW  20
1244:  BTFSS  0C.4
1245:  GOTO   244
1246:  MOVWF  19
1247:  MOVLW  41
1248:  MOVWF  04
1249:  MOVF   2D,W
124A:  MOVWF  59
124B:  MOVF   2C,W
124C:  MOVWF  58
124D:  MOVF   2B,W
124E:  MOVWF  57
124F:  MOVF   2A,W
1250:  MOVWF  56
1251:  BCF    0A.4
1252:  CALL   4E7
1253:  BSF    0A.4
1254:  MOVLW  20
1255:  BTFSS  0C.4
1256:  GOTO   255
1257:  MOVWF  19
1258:  MOVLW  3D
1259:  BTFSS  0C.4
125A:  GOTO   259
125B:  MOVWF  19
125C:  MOVLW  20
125D:  BTFSS  0C.4
125E:  GOTO   25D
125F:  MOVWF  19
1260:  MOVLW  41
1261:  MOVWF  04
1262:  MOVF   47,W
1263:  MOVWF  59
1264:  MOVF   46,W
1265:  MOVWF  58
1266:  MOVF   45,W
1267:  MOVWF  57
1268:  MOVF   44,W
1269:  MOVWF  56
126A:  BCF    0A.4
126B:  CALL   4E7
126C:  BSF    0A.4
126D:  MOVLW  0D
126E:  BTFSS  0C.4
126F:  GOTO   26E
1270:  MOVWF  19
1271:  GOTO   394
....................    case multiply: printf("*");putc(13);printf("Ket qua %ld * %ld = %ld",a,b,a*b);putc(13); break; 
1272:  MOVLW  2A
1273:  BTFSS  0C.4
1274:  GOTO   273
1275:  MOVWF  19
1276:  MOVLW  0D
1277:  BTFSS  0C.4
1278:  GOTO   277
1279:  MOVWF  19
127A:  MOVF   29,W
127B:  MOVWF  65
127C:  MOVF   28,W
127D:  MOVWF  64
127E:  MOVF   27,W
127F:  MOVWF  63
1280:  MOVF   26,W
1281:  MOVWF  62
1282:  MOVF   2D,W
1283:  MOVWF  69
1284:  MOVF   2C,W
1285:  MOVWF  68
1286:  MOVF   2B,W
1287:  MOVWF  67
1288:  MOVF   2A,W
1289:  MOVWF  66
128A:  BCF    0A.4
128B:  CALL   367
128C:  BSF    0A.4
128D:  MOVF   7A,W
128E:  MOVWF  47
128F:  MOVF   79,W
1290:  MOVWF  46
1291:  MOVF   78,W
1292:  MOVWF  45
1293:  MOVF   77,W
1294:  MOVWF  44
1295:  MOVLW  A4
1296:  BSF    03.6
1297:  MOVWF  0D
1298:  MOVLW  00
1299:  MOVWF  0F
129A:  BCF    03.0
129B:  MOVLW  08
129C:  BCF    03.6
129D:  MOVWF  56
129E:  BCF    0A.4
129F:  CALL   43F
12A0:  BSF    0A.4
12A1:  MOVLW  41
12A2:  MOVWF  04
12A3:  MOVF   29,W
12A4:  MOVWF  59
12A5:  MOVF   28,W
12A6:  MOVWF  58
12A7:  MOVF   27,W
12A8:  MOVWF  57
12A9:  MOVF   26,W
12AA:  MOVWF  56
12AB:  BCF    0A.4
12AC:  CALL   4E7
12AD:  BSF    0A.4
12AE:  MOVLW  20
12AF:  BTFSS  0C.4
12B0:  GOTO   2AF
12B1:  MOVWF  19
12B2:  MOVLW  2A
12B3:  BTFSS  0C.4
12B4:  GOTO   2B3
12B5:  MOVWF  19
12B6:  MOVLW  20
12B7:  BTFSS  0C.4
12B8:  GOTO   2B7
12B9:  MOVWF  19
12BA:  MOVLW  41
12BB:  MOVWF  04
12BC:  MOVF   2D,W
12BD:  MOVWF  59
12BE:  MOVF   2C,W
12BF:  MOVWF  58
12C0:  MOVF   2B,W
12C1:  MOVWF  57
12C2:  MOVF   2A,W
12C3:  MOVWF  56
12C4:  BCF    0A.4
12C5:  CALL   4E7
12C6:  BSF    0A.4
12C7:  MOVLW  20
12C8:  BTFSS  0C.4
12C9:  GOTO   2C8
12CA:  MOVWF  19
12CB:  MOVLW  3D
12CC:  BTFSS  0C.4
12CD:  GOTO   2CC
12CE:  MOVWF  19
12CF:  MOVLW  20
12D0:  BTFSS  0C.4
12D1:  GOTO   2D0
12D2:  MOVWF  19
12D3:  MOVLW  41
12D4:  MOVWF  04
12D5:  MOVF   47,W
12D6:  MOVWF  59
12D7:  MOVF   46,W
12D8:  MOVWF  58
12D9:  MOVF   45,W
12DA:  MOVWF  57
12DB:  MOVF   44,W
12DC:  MOVWF  56
12DD:  BCF    0A.4
12DE:  CALL   4E7
12DF:  BSF    0A.4
12E0:  MOVLW  0D
12E1:  BTFSS  0C.4
12E2:  GOTO   2E1
12E3:  MOVWF  19
12E4:  GOTO   394
....................    case divide: 
....................    printf("/");putc(13); 
12E5:  MOVLW  2F
12E6:  BTFSS  0C.4
12E7:  GOTO   2E6
12E8:  MOVWF  19
12E9:  MOVLW  0D
12EA:  BTFSS  0C.4
12EB:  GOTO   2EA
12EC:  MOVWF  19
....................    if ( b == 0){loiSyntax();}  
12ED:  MOVF   2A,F
12EE:  BTFSS  03.2
12EF:  GOTO   2FD
12F0:  MOVF   2B,F
12F1:  BTFSS  03.2
12F2:  GOTO   2FD
12F3:  MOVF   2C,F
12F4:  BTFSS  03.2
12F5:  GOTO   2FD
12F6:  MOVF   2D,F
12F7:  BTFSS  03.2
12F8:  GOTO   2FD
12F9:  BCF    0A.4
12FA:  CALL   355
12FB:  BSF    0A.4
12FC:  GOTO   38B
....................    else 
....................    { 
....................    a1 = a; 
12FD:  MOVF   29,W
12FE:  MOVWF  55
12FF:  MOVF   28,W
1300:  MOVWF  54
1301:  MOVF   27,W
1302:  MOVWF  53
1303:  MOVF   26,W
1304:  MOVWF  52
1305:  BCF    0A.4
1306:  CALL   568
1307:  BSF    0A.4
1308:  MOVF   7A,W
1309:  MOVWF  35
130A:  MOVF   79,W
130B:  MOVWF  34
130C:  MOVF   78,W
130D:  MOVWF  33
130E:  MOVF   77,W
130F:  MOVWF  32
....................    b1 = b; 
1310:  MOVF   2D,W
1311:  MOVWF  55
1312:  MOVF   2C,W
1313:  MOVWF  54
1314:  MOVF   2B,W
1315:  MOVWF  53
1316:  MOVF   2A,W
1317:  MOVWF  52
1318:  BCF    0A.4
1319:  CALL   568
131A:  BSF    0A.4
131B:  MOVF   7A,W
131C:  MOVWF  39
131D:  MOVF   79,W
131E:  MOVWF  38
131F:  MOVF   78,W
1320:  MOVWF  37
1321:  MOVF   77,W
1322:  MOVWF  36
....................    x = a1/b1; 
1323:  MOVF   35,W
1324:  MOVWF  73
1325:  MOVF   34,W
1326:  MOVWF  72
1327:  MOVF   33,W
1328:  MOVWF  71
1329:  MOVF   32,W
132A:  MOVWF  70
132B:  MOVF   39,W
132C:  MOVWF  7E
132D:  MOVF   38,W
132E:  MOVWF  7D
132F:  MOVF   37,W
1330:  MOVWF  7C
1331:  MOVF   36,W
1332:  MOVWF  7B
1333:  BCF    0A.4
1334:  CALL   596
1335:  BSF    0A.4
1336:  MOVF   7A,W
1337:  MOVWF  41
1338:  MOVF   79,W
1339:  MOVWF  40
133A:  MOVF   78,W
133B:  MOVWF  3F
133C:  MOVF   77,W
133D:  MOVWF  3E
....................    printf("Ket qua %ld / %ld = %f",a,b,x);} 
133E:  MOVLW  B0
133F:  BSF    03.6
1340:  MOVWF  0D
1341:  MOVLW  00
1342:  MOVWF  0F
1343:  BCF    03.0
1344:  MOVLW  08
1345:  BCF    03.6
1346:  MOVWF  56
1347:  BCF    0A.4
1348:  CALL   43F
1349:  BSF    0A.4
134A:  MOVLW  41
134B:  MOVWF  04
134C:  MOVF   29,W
134D:  MOVWF  59
134E:  MOVF   28,W
134F:  MOVWF  58
1350:  MOVF   27,W
1351:  MOVWF  57
1352:  MOVF   26,W
1353:  MOVWF  56
1354:  BCF    0A.4
1355:  CALL   4E7
1356:  BSF    0A.4
1357:  MOVLW  20
1358:  BTFSS  0C.4
1359:  GOTO   358
135A:  MOVWF  19
135B:  MOVLW  2F
135C:  BTFSS  0C.4
135D:  GOTO   35C
135E:  MOVWF  19
135F:  MOVLW  20
1360:  BTFSS  0C.4
1361:  GOTO   360
1362:  MOVWF  19
1363:  MOVLW  41
1364:  MOVWF  04
1365:  MOVF   2D,W
1366:  MOVWF  59
1367:  MOVF   2C,W
1368:  MOVWF  58
1369:  MOVF   2B,W
136A:  MOVWF  57
136B:  MOVF   2A,W
136C:  MOVWF  56
136D:  BCF    0A.4
136E:  CALL   4E7
136F:  BSF    0A.4
1370:  MOVLW  20
1371:  BTFSS  0C.4
1372:  GOTO   371
1373:  MOVWF  19
1374:  MOVLW  3D
1375:  BTFSS  0C.4
1376:  GOTO   375
1377:  MOVWF  19
1378:  MOVLW  20
1379:  BTFSS  0C.4
137A:  GOTO   379
137B:  MOVWF  19
137C:  MOVLW  89
137D:  MOVWF  04
137E:  MOVF   41,W
137F:  MOVWF  51
1380:  MOVF   40,W
1381:  MOVWF  50
1382:  MOVF   3F,W
1383:  MOVWF  4F
1384:  MOVF   3E,W
1385:  MOVWF  4E
1386:  MOVLW  02
1387:  MOVWF  52
1388:  BCF    0A.4
1389:  CALL   6E4
138A:  BSF    0A.4
....................    putc(13); 
138B:  MOVLW  0D
138C:  BTFSS  0C.4
138D:  GOTO   38C
138E:  MOVWF  19
....................    break;   
138F:  GOTO   394
....................    default: loiSyntax();break; 
1390:  BCF    0A.4
1391:  CALL   355
1392:  BSF    0A.4
1393:  GOTO   394
....................    break; 
....................    } 
....................    } 
1394:  GOTO   722
....................    else if ( cn1 == 'P' || cn1 == 'p') 
1395:  MOVF   25,W
1396:  SUBLW  50
1397:  BTFSC  03.2
1398:  GOTO   39D
1399:  MOVF   25,W
139A:  SUBLW  70
139B:  BTFSS  03.2
139C:  GOTO   488
....................    {  
....................    printf("Phuong trinh bac 1: ax + b = c");putc(13); 
139D:  MOVLW  BC
139E:  BSF    03.6
139F:  MOVWF  0D
13A0:  MOVLW  00
13A1:  MOVWF  0F
13A2:  BCF    0A.4
13A3:  BCF    03.6
13A4:  CALL   2E9
13A5:  BSF    0A.4
13A6:  MOVLW  0D
13A7:  BTFSS  0C.4
13A8:  GOTO   3A7
13A9:  MOVWF  19
....................    printf("Nhap a: "); a = nhap_so();a1=a; 
13AA:  MOVLW  CC
13AB:  BSF    03.6
13AC:  MOVWF  0D
13AD:  MOVLW  00
13AE:  MOVWF  0F
13AF:  BCF    0A.4
13B0:  BCF    03.6
13B1:  CALL   2E9
13B2:  BSF    0A.4
13B3:  BCF    0A.4
13B4:  CALL   391
13B5:  BSF    0A.4
13B6:  MOVF   7A,W
13B7:  MOVWF  29
13B8:  MOVF   79,W
13B9:  MOVWF  28
13BA:  MOVF   78,W
13BB:  MOVWF  27
13BC:  MOVF   77,W
13BD:  MOVWF  26
13BE:  MOVF   29,W
13BF:  MOVWF  55
13C0:  MOVF   28,W
13C1:  MOVWF  54
13C2:  MOVF   27,W
13C3:  MOVWF  53
13C4:  MOVF   26,W
13C5:  MOVWF  52
13C6:  BCF    0A.4
13C7:  CALL   568
13C8:  BSF    0A.4
13C9:  MOVF   7A,W
13CA:  MOVWF  35
13CB:  MOVF   79,W
13CC:  MOVWF  34
13CD:  MOVF   78,W
13CE:  MOVWF  33
13CF:  MOVF   77,W
13D0:  MOVWF  32
....................    printf("Nhap b: "); b = nhap_so();b1=b; 
13D1:  MOVLW  D1
13D2:  BSF    03.6
13D3:  MOVWF  0D
13D4:  MOVLW  00
13D5:  MOVWF  0F
13D6:  BCF    0A.4
13D7:  BCF    03.6
13D8:  CALL   2E9
13D9:  BSF    0A.4
13DA:  BCF    0A.4
13DB:  CALL   391
13DC:  BSF    0A.4
13DD:  MOVF   7A,W
13DE:  MOVWF  2D
13DF:  MOVF   79,W
13E0:  MOVWF  2C
13E1:  MOVF   78,W
13E2:  MOVWF  2B
13E3:  MOVF   77,W
13E4:  MOVWF  2A
13E5:  MOVF   2D,W
13E6:  MOVWF  55
13E7:  MOVF   2C,W
13E8:  MOVWF  54
13E9:  MOVF   2B,W
13EA:  MOVWF  53
13EB:  MOVF   2A,W
13EC:  MOVWF  52
13ED:  BCF    0A.4
13EE:  CALL   568
13EF:  BSF    0A.4
13F0:  MOVF   7A,W
13F1:  MOVWF  39
13F2:  MOVF   79,W
13F3:  MOVWF  38
13F4:  MOVF   78,W
13F5:  MOVWF  37
13F6:  MOVF   77,W
13F7:  MOVWF  36
....................    printf("Nhap c: "); c = nhap_so();c1=c; 
13F8:  MOVLW  D6
13F9:  BSF    03.6
13FA:  MOVWF  0D
13FB:  MOVLW  00
13FC:  MOVWF  0F
13FD:  BCF    0A.4
13FE:  BCF    03.6
13FF:  CALL   2E9
1400:  BSF    0A.4
1401:  BCF    0A.4
1402:  CALL   391
1403:  BSF    0A.4
1404:  MOVF   7A,W
1405:  MOVWF  31
1406:  MOVF   79,W
1407:  MOVWF  30
1408:  MOVF   78,W
1409:  MOVWF  2F
140A:  MOVF   77,W
140B:  MOVWF  2E
140C:  MOVF   31,W
140D:  MOVWF  55
140E:  MOVF   30,W
140F:  MOVWF  54
1410:  MOVF   2F,W
1411:  MOVWF  53
1412:  MOVF   2E,W
1413:  MOVWF  52
1414:  BCF    0A.4
1415:  CALL   568
1416:  BSF    0A.4
1417:  MOVF   7A,W
1418:  MOVWF  3D
1419:  MOVF   79,W
141A:  MOVWF  3C
141B:  MOVF   78,W
141C:  MOVWF  3B
141D:  MOVF   77,W
141E:  MOVWF  3A
....................    if (a == 0 ) {loiSyntax();} 
141F:  MOVF   26,F
1420:  BTFSS  03.2
1421:  GOTO   42F
1422:  MOVF   27,F
1423:  BTFSS  03.2
1424:  GOTO   42F
1425:  MOVF   28,F
1426:  BTFSS  03.2
1427:  GOTO   42F
1428:  MOVF   29,F
1429:  BTFSS  03.2
142A:  GOTO   42F
142B:  BCF    0A.4
142C:  CALL   355
142D:  BSF    0A.4
142E:  GOTO   487
....................    else{ 
....................    x = (c1-b1)/a1; 
142F:  BSF    03.1
1430:  MOVF   3D,W
1431:  MOVWF  73
1432:  MOVF   3C,W
1433:  MOVWF  72
1434:  MOVF   3B,W
1435:  MOVWF  71
1436:  MOVF   3A,W
1437:  MOVWF  70
1438:  MOVF   39,W
1439:  MOVWF  7E
143A:  MOVF   38,W
143B:  MOVWF  7D
143C:  MOVF   37,W
143D:  MOVWF  7C
143E:  MOVF   36,W
143F:  MOVWF  7B
1440:  BCF    0A.4
1441:  BSF    0A.3
1442:  CALL   000
1443:  BSF    0A.4
1444:  BCF    0A.3
1445:  MOVF   7A,W
1446:  MOVWF  47
1447:  MOVF   79,W
1448:  MOVWF  46
1449:  MOVF   78,W
144A:  MOVWF  45
144B:  MOVF   77,W
144C:  MOVWF  44
144D:  MOVF   7A,W
144E:  MOVWF  73
144F:  MOVF   79,W
1450:  MOVWF  72
1451:  MOVF   78,W
1452:  MOVWF  71
1453:  MOVF   77,W
1454:  MOVWF  70
1455:  MOVF   35,W
1456:  MOVWF  7E
1457:  MOVF   34,W
1458:  MOVWF  7D
1459:  MOVF   33,W
145A:  MOVWF  7C
145B:  MOVF   32,W
145C:  MOVWF  7B
145D:  BCF    0A.4
145E:  CALL   596
145F:  BSF    0A.4
1460:  MOVF   7A,W
1461:  MOVWF  41
1462:  MOVF   79,W
1463:  MOVWF  40
1464:  MOVF   78,W
1465:  MOVWF  3F
1466:  MOVF   77,W
1467:  MOVWF  3E
....................    printf("x = %f",x);putc(13);} 
1468:  MOVLW  DB
1469:  BSF    03.6
146A:  MOVWF  0D
146B:  MOVLW  00
146C:  MOVWF  0F
146D:  BCF    03.0
146E:  MOVLW  04
146F:  BCF    03.6
1470:  MOVWF  56
1471:  BCF    0A.4
1472:  CALL   43F
1473:  BSF    0A.4
1474:  MOVLW  89
1475:  MOVWF  04
1476:  MOVF   41,W
1477:  MOVWF  51
1478:  MOVF   40,W
1479:  MOVWF  50
147A:  MOVF   3F,W
147B:  MOVWF  4F
147C:  MOVF   3E,W
147D:  MOVWF  4E
147E:  MOVLW  02
147F:  MOVWF  52
1480:  BCF    0A.4
1481:  CALL   6E4
1482:  BSF    0A.4
1483:  MOVLW  0D
1484:  BTFSS  0C.4
1485:  GOTO   484
1486:  MOVWF  19
....................    } 
1487:  GOTO   722
....................    else if(cn1 == 'm' || cn1 == 'M') 
1488:  MOVF   25,W
1489:  SUBLW  6D
148A:  BTFSC  03.2
148B:  GOTO   490
148C:  MOVF   25,W
148D:  SUBLW  4D
148E:  BTFSS  03.2
148F:  GOTO   553
....................    { 
....................    printf("Tinh so mu");putc(13); 
1490:  MOVLW  DF
1491:  BSF    03.6
1492:  MOVWF  0D
1493:  MOVLW  00
1494:  MOVWF  0F
1495:  BCF    0A.4
1496:  BCF    03.6
1497:  CALL   2E9
1498:  BSF    0A.4
1499:  MOVLW  0D
149A:  BTFSS  0C.4
149B:  GOTO   49A
149C:  MOVWF  19
....................    printf("Nhap a: "); a = nhap_so(); 
149D:  MOVLW  E5
149E:  BSF    03.6
149F:  MOVWF  0D
14A0:  MOVLW  00
14A1:  MOVWF  0F
14A2:  BCF    0A.4
14A3:  BCF    03.6
14A4:  CALL   2E9
14A5:  BSF    0A.4
14A6:  BCF    0A.4
14A7:  CALL   391
14A8:  BSF    0A.4
14A9:  MOVF   7A,W
14AA:  MOVWF  29
14AB:  MOVF   79,W
14AC:  MOVWF  28
14AD:  MOVF   78,W
14AE:  MOVWF  27
14AF:  MOVF   77,W
14B0:  MOVWF  26
....................    printf("Nhap b: "); b = nhap_so(); 
14B1:  MOVLW  EA
14B2:  BSF    03.6
14B3:  MOVWF  0D
14B4:  MOVLW  00
14B5:  MOVWF  0F
14B6:  BCF    0A.4
14B7:  BCF    03.6
14B8:  CALL   2E9
14B9:  BSF    0A.4
14BA:  BCF    0A.4
14BB:  CALL   391
14BC:  BSF    0A.4
14BD:  MOVF   7A,W
14BE:  MOVWF  2D
14BF:  MOVF   79,W
14C0:  MOVWF  2C
14C1:  MOVF   78,W
14C2:  MOVWF  2B
14C3:  MOVF   77,W
14C4:  MOVWF  2A
....................    printf("%ld^%ld = %ld",a,b,power(a,b)); putc(13); 
14C5:  MOVF   29,W
14C6:  MOVWF  47
14C7:  MOVF   28,W
14C8:  MOVWF  46
14C9:  MOVF   27,W
14CA:  MOVWF  45
14CB:  MOVF   26,W
14CC:  MOVWF  44
14CD:  MOVF   2D,W
14CE:  MOVWF  4B
14CF:  MOVF   2C,W
14D0:  MOVWF  4A
14D1:  MOVF   2B,W
14D2:  MOVWF  49
14D3:  MOVF   2A,W
14D4:  MOVWF  48
*
150F:  MOVF   7A,W
1510:  MOVWF  47
1511:  MOVF   79,W
1512:  MOVWF  46
1513:  MOVF   78,W
1514:  MOVWF  45
1515:  MOVF   77,W
1516:  MOVWF  44
1517:  MOVLW  41
1518:  MOVWF  04
1519:  MOVF   29,W
151A:  MOVWF  59
151B:  MOVF   28,W
151C:  MOVWF  58
151D:  MOVF   27,W
151E:  MOVWF  57
151F:  MOVF   26,W
1520:  MOVWF  56
1521:  BCF    0A.4
1522:  CALL   4E7
1523:  BSF    0A.4
1524:  MOVLW  5E
1525:  BTFSS  0C.4
1526:  GOTO   525
1527:  MOVWF  19
1528:  MOVLW  41
1529:  MOVWF  04
152A:  MOVF   2D,W
152B:  MOVWF  59
152C:  MOVF   2C,W
152D:  MOVWF  58
152E:  MOVF   2B,W
152F:  MOVWF  57
1530:  MOVF   2A,W
1531:  MOVWF  56
1532:  BCF    0A.4
1533:  CALL   4E7
1534:  BSF    0A.4
1535:  MOVLW  20
1536:  BTFSS  0C.4
1537:  GOTO   536
1538:  MOVWF  19
1539:  MOVLW  3D
153A:  BTFSS  0C.4
153B:  GOTO   53A
153C:  MOVWF  19
153D:  MOVLW  20
153E:  BTFSS  0C.4
153F:  GOTO   53E
1540:  MOVWF  19
1541:  MOVLW  41
1542:  MOVWF  04
1543:  MOVF   47,W
1544:  MOVWF  59
1545:  MOVF   46,W
1546:  MOVWF  58
1547:  MOVF   45,W
1548:  MOVWF  57
1549:  MOVF   44,W
154A:  MOVWF  56
154B:  BCF    0A.4
154C:  CALL   4E7
154D:  BSF    0A.4
154E:  MOVLW  0D
154F:  BTFSS  0C.4
1550:  GOTO   54F
1551:  MOVWF  19
....................    } 
1552:  GOTO   722
....................  else if (cn1=='D' || cn1=='d') 
1553:  MOVF   25,W
1554:  SUBLW  44
1555:  BTFSC  03.2
1556:  GOTO   55B
1557:  MOVF   25,W
1558:  SUBLW  64
1559:  BTFSS  03.2
155A:  GOTO   5EB
....................    { 
....................    printf("Tri tuyet doi");putc(13); 
155B:  MOVLW  EF
155C:  BSF    03.6
155D:  MOVWF  0D
155E:  MOVLW  00
155F:  MOVWF  0F
1560:  BCF    0A.4
1561:  BCF    03.6
1562:  CALL   2E9
1563:  BSF    0A.4
1564:  MOVLW  0D
1565:  BTFSS  0C.4
1566:  GOTO   565
1567:  MOVWF  19
....................    printf("Nhap a: "); 
1568:  MOVLW  F6
1569:  BSF    03.6
156A:  MOVWF  0D
156B:  MOVLW  00
156C:  MOVWF  0F
156D:  BCF    0A.4
156E:  BCF    03.6
156F:  CALL   2E9
1570:  BSF    0A.4
....................    a = nhap_so(); 
1571:  BCF    0A.4
1572:  CALL   391
1573:  BSF    0A.4
1574:  MOVF   7A,W
1575:  MOVWF  29
1576:  MOVF   79,W
1577:  MOVWF  28
1578:  MOVF   78,W
1579:  MOVWF  27
157A:  MOVF   77,W
157B:  MOVWF  26
....................    if ( a>= 0 ) {printf("|%ld| = %ld",a,a);putc(13);} 
157C:  BTFSC  29.7
157D:  GOTO   5AD
157E:  MOVLW  7C
157F:  BTFSS  0C.4
1580:  GOTO   57F
1581:  MOVWF  19
1582:  MOVLW  41
1583:  MOVWF  04
1584:  MOVF   29,W
1585:  MOVWF  59
1586:  MOVF   28,W
1587:  MOVWF  58
1588:  MOVF   27,W
1589:  MOVWF  57
158A:  MOVF   26,W
158B:  MOVWF  56
158C:  BCF    0A.4
158D:  CALL   4E7
158E:  BSF    0A.4
158F:  MOVLW  FD
1590:  BSF    03.6
1591:  MOVWF  0D
1592:  MOVLW  00
1593:  MOVWF  0F
1594:  BCF    03.0
1595:  MOVLW  04
1596:  BCF    03.6
1597:  MOVWF  56
1598:  BCF    0A.4
1599:  CALL   43F
159A:  BSF    0A.4
159B:  MOVLW  41
159C:  MOVWF  04
159D:  MOVF   29,W
159E:  MOVWF  59
159F:  MOVF   28,W
15A0:  MOVWF  58
15A1:  MOVF   27,W
15A2:  MOVWF  57
15A3:  MOVF   26,W
15A4:  MOVWF  56
15A5:  BCF    0A.4
15A6:  CALL   4E7
15A7:  BSF    0A.4
15A8:  MOVLW  0D
15A9:  BTFSS  0C.4
15AA:  GOTO   5A9
15AB:  MOVWF  19
15AC:  GOTO   5EA
....................    else {printf("|%ld| = %ld",a,-a);putc(13);}   
15AD:  COMF   26,W
15AE:  MOVWF  44
15AF:  COMF   27,W
15B0:  MOVWF  45
15B1:  COMF   28,W
15B2:  MOVWF  46
15B3:  COMF   29,W
15B4:  MOVWF  47
15B5:  INCF   44,F
15B6:  BTFSC  03.2
15B7:  INCF   45,F
15B8:  BTFSC  03.2
15B9:  INCF   46,F
15BA:  BTFSC  03.2
15BB:  INCF   47,F
15BC:  MOVLW  7C
15BD:  BTFSS  0C.4
15BE:  GOTO   5BD
15BF:  MOVWF  19
15C0:  MOVLW  41
15C1:  MOVWF  04
15C2:  MOVF   29,W
15C3:  MOVWF  59
15C4:  MOVF   28,W
15C5:  MOVWF  58
15C6:  MOVF   27,W
15C7:  MOVWF  57
15C8:  MOVF   26,W
15C9:  MOVWF  56
15CA:  BCF    0A.4
15CB:  CALL   4E7
15CC:  BSF    0A.4
15CD:  MOVLW  03
15CE:  BSF    03.6
15CF:  MOVWF  0D
15D0:  MOVLW  01
15D1:  MOVWF  0F
15D2:  BCF    03.0
15D3:  MOVLW  04
15D4:  BCF    03.6
15D5:  MOVWF  56
15D6:  BCF    0A.4
15D7:  CALL   43F
15D8:  BSF    0A.4
15D9:  MOVLW  41
15DA:  MOVWF  04
15DB:  MOVF   47,W
15DC:  MOVWF  59
15DD:  MOVF   46,W
15DE:  MOVWF  58
15DF:  MOVF   45,W
15E0:  MOVWF  57
15E1:  MOVF   44,W
15E2:  MOVWF  56
15E3:  BCF    0A.4
15E4:  CALL   4E7
15E5:  BSF    0A.4
15E6:  MOVLW  0D
15E7:  BTFSS  0C.4
15E8:  GOTO   5E7
15E9:  MOVWF  19
....................    } 
15EA:  GOTO   722
....................    else if (cn1 == 'N' || cn1 == 'n') 
15EB:  MOVF   25,W
15EC:  SUBLW  4E
15ED:  BTFSC  03.2
15EE:  GOTO   5F3
15EF:  MOVF   25,W
15F0:  SUBLW  6E
15F1:  BTFSS  03.2
15F2:  GOTO   71F
....................    { 
....................    int kt=1; 
15F3:  MOVLW  01
15F4:  MOVWF  42
....................    printf("Kiem tra so nguyen to");putc(13); 
15F5:  MOVLW  07
15F6:  BSF    03.6
15F7:  MOVWF  0D
15F8:  MOVLW  01
15F9:  MOVWF  0F
15FA:  BCF    0A.4
15FB:  BCF    03.6
15FC:  CALL   2E9
15FD:  BSF    0A.4
15FE:  MOVLW  0D
15FF:  BTFSS  0C.4
1600:  GOTO   5FF
1601:  MOVWF  19
....................    printf("Nhap a: "); a = nhap_so(); 
1602:  MOVLW  12
1603:  BSF    03.6
1604:  MOVWF  0D
1605:  MOVLW  01
1606:  MOVWF  0F
1607:  BCF    0A.4
1608:  BCF    03.6
1609:  CALL   2E9
160A:  BSF    0A.4
160B:  BCF    0A.4
160C:  CALL   391
160D:  BSF    0A.4
160E:  MOVF   7A,W
160F:  MOVWF  29
1610:  MOVF   79,W
1611:  MOVWF  28
1612:  MOVF   78,W
1613:  MOVWF  27
1614:  MOVF   77,W
1615:  MOVWF  26
....................    if (a == 0|| a==1){printf("a khong phai so nguyen to"); putc(13); kt=0;} 
1616:  MOVF   26,F
1617:  BTFSS  03.2
1618:  GOTO   622
1619:  MOVF   27,F
161A:  BTFSS  03.2
161B:  GOTO   622
161C:  MOVF   28,F
161D:  BTFSS  03.2
161E:  GOTO   622
161F:  MOVF   29,F
1620:  BTFSC  03.2
1621:  GOTO   62D
1622:  DECFSZ 26,W
1623:  GOTO   63C
1624:  MOVF   27,F
1625:  BTFSS  03.2
1626:  GOTO   63C
1627:  MOVF   28,F
1628:  BTFSS  03.2
1629:  GOTO   63C
162A:  MOVF   29,F
162B:  BTFSS  03.2
162C:  GOTO   63C
162D:  MOVLW  17
162E:  BSF    03.6
162F:  MOVWF  0D
1630:  MOVLW  01
1631:  MOVWF  0F
1632:  BCF    0A.4
1633:  BCF    03.6
1634:  CALL   2E9
1635:  BSF    0A.4
1636:  MOVLW  0D
1637:  BTFSS  0C.4
1638:  GOTO   637
1639:  MOVWF  19
163A:  CLRF   42
163B:  GOTO   700
....................    else  
....................    { 
....................       for(int i=2; i<=a/2; i++) 
163C:  MOVLW  02
163D:  MOVWF  43
163E:  BCF    03.1
163F:  MOVF   29,W
1640:  MOVWF  47
1641:  MOVF   28,W
1642:  MOVWF  46
1643:  MOVF   27,W
1644:  MOVWF  45
1645:  MOVF   26,W
1646:  MOVWF  44
1647:  CLRF   4B
1648:  CLRF   4A
1649:  CLRF   49
164A:  MOVLW  02
164B:  MOVWF  48
*
16C5:  BTFSC  7A.7
16C6:  GOTO   700
16C7:  MOVF   7A,F
16C8:  BTFSS  03.2
16C9:  GOTO   6D4
16CA:  MOVF   79,F
16CB:  BTFSS  03.2
16CC:  GOTO   6D4
16CD:  MOVF   78,F
16CE:  BTFSS  03.2
16CF:  GOTO   6D4
16D0:  MOVF   43,W
16D1:  SUBWF  77,W
16D2:  BTFSS  03.0
16D3:  GOTO   700
....................          { 
....................             if((int) a % i ==0) {printf("a khong phai so nguyen to"); putc(13); kt=0;break;} 
16D4:  MOVF   26,W
16D5:  MOVWF  44
16D6:  MOVF   43,W
16D7:  MOVWF  45
*
16EC:  MOVF   77,F
16ED:  BTFSS  03.2
16EE:  GOTO   6FE
16EF:  MOVLW  24
16F0:  BSF    03.6
16F1:  MOVWF  0D
16F2:  MOVLW  01
16F3:  MOVWF  0F
16F4:  BCF    0A.4
16F5:  BCF    03.6
16F6:  CALL   2E9
16F7:  BSF    0A.4
16F8:  MOVLW  0D
16F9:  BTFSS  0C.4
16FA:  GOTO   6F9
16FB:  MOVWF  19
16FC:  CLRF   42
16FD:  GOTO   700
16FE:  INCF   43,F
16FF:  GOTO   63E
....................          } 
....................    } 
....................    if(kt) {printf("a la so nguyen to"); putc(13);} 
1700:  MOVF   42,F
1701:  BTFSC  03.2
1702:  GOTO   711
1703:  MOVLW  31
1704:  BSF    03.6
1705:  MOVWF  0D
1706:  MOVLW  01
1707:  MOVWF  0F
1708:  BCF    0A.4
1709:  BCF    03.6
170A:  CALL   2E9
170B:  BSF    0A.4
170C:  MOVLW  0D
170D:  BTFSS  0C.4
170E:  GOTO   70D
170F:  MOVWF  19
1710:  GOTO   71E
....................    else {printf("a khong phai so nguyen to"); putc(13);} 
1711:  MOVLW  3A
1712:  BSF    03.6
1713:  MOVWF  0D
1714:  MOVLW  01
1715:  MOVWF  0F
1716:  BCF    0A.4
1717:  BCF    03.6
1718:  CALL   2E9
1719:  BSF    0A.4
171A:  MOVLW  0D
171B:  BTFSS  0C.4
171C:  GOTO   71B
171D:  MOVWF  19
....................    } 
171E:  GOTO   722
....................    else {loiSyntax();} 
171F:  BCF    0A.4
1720:  CALL   355
1721:  BSF    0A.4
.................... } 
....................  //ket thuc mien thuc 
....................  
....................  
....................  
.................... #include <mienphuc.c> 
.................... #use delay(clock=20M) 
.................... #use rs232(baud=9600,xmit=PIN_C6,rcv=PIN_C7) 
.................... float biendo(long long a, long long b) 
.................... { 
....................    float x; 
....................    return x = sqrt((a*a)+(b*b)); 
*
0982:  MOVF   55,W
0983:  MOVWF  65
0984:  MOVF   54,W
0985:  MOVWF  64
0986:  MOVF   53,W
0987:  MOVWF  63
0988:  MOVF   52,W
0989:  MOVWF  62
098A:  MOVF   55,W
098B:  MOVWF  69
098C:  MOVF   54,W
098D:  MOVWF  68
098E:  MOVF   53,W
098F:  MOVWF  67
0990:  MOVF   52,W
0991:  MOVWF  66
0992:  BCF    0A.3
0993:  CALL   367
0994:  BSF    0A.3
0995:  MOVF   7A,W
0996:  MOVWF  61
0997:  MOVF   79,W
0998:  MOVWF  60
0999:  MOVF   78,W
099A:  MOVWF  5F
099B:  MOVF   77,W
099C:  MOVWF  5E
099D:  MOVF   59,W
099E:  MOVWF  65
099F:  MOVF   58,W
09A0:  MOVWF  64
09A1:  MOVF   57,W
09A2:  MOVWF  63
09A3:  MOVF   56,W
09A4:  MOVWF  62
09A5:  MOVF   59,W
09A6:  MOVWF  69
09A7:  MOVF   58,W
09A8:  MOVWF  68
09A9:  MOVF   57,W
09AA:  MOVWF  67
09AB:  MOVF   56,W
09AC:  MOVWF  66
09AD:  BCF    0A.3
09AE:  CALL   367
09AF:  BSF    0A.3
09B0:  MOVF   5E,W
09B1:  ADDWF  77,F
09B2:  MOVF   5F,W
09B3:  BTFSC  03.0
09B4:  INCFSZ 5F,W
09B5:  ADDWF  78,F
09B6:  MOVF   60,W
09B7:  BTFSC  03.0
09B8:  INCFSZ 60,W
09B9:  ADDWF  79,F
09BA:  MOVF   61,W
09BB:  BTFSC  03.0
09BC:  INCFSZ 61,W
09BD:  ADDWF  7A,F
09BE:  MOVF   7A,W
09BF:  MOVWF  61
09C0:  MOVF   79,W
09C1:  MOVWF  60
09C2:  MOVF   78,W
09C3:  MOVWF  5F
09C4:  MOVF   77,W
09C5:  MOVWF  5E
*
09E0:  MOVF   7A,W
09E1:  MOVWF  61
09E2:  MOVF   79,W
09E3:  MOVWF  60
09E4:  MOVF   78,W
09E5:  MOVWF  5F
09E6:  MOVF   77,W
09E7:  MOVWF  5E
09E8:  MOVF   61,W
09E9:  MOVWF  65
09EA:  MOVF   60,W
09EB:  MOVWF  64
09EC:  MOVF   5F,W
09ED:  MOVWF  63
09EE:  MOVF   5E,W
09EF:  MOVWF  62
*
0A80:  MOVF   7A,W
0A81:  MOVWF  5D
0A82:  MOVF   79,W
0A83:  MOVWF  5C
0A84:  MOVF   78,W
0A85:  MOVWF  5B
0A86:  MOVF   77,W
0A87:  MOVWF  5A
0A88:  MOVWF  77
0A89:  MOVF   5B,W
0A8A:  MOVWF  78
0A8B:  MOVF   5C,W
0A8C:  MOVWF  79
0A8D:  MOVF   5D,W
0A8E:  MOVWF  7A
0A8F:  RETURN
.................... } 
.................... void mienphuc() 
....................       { 
....................          printf("Phep toan don gian: nhan T hoac t");putc(13); 
0A90:  MOVLW  47
0A91:  BSF    03.6
0A92:  MOVWF  0D
0A93:  MOVLW  01
0A94:  MOVWF  0F
0A95:  BCF    0A.3
0A96:  BCF    03.6
0A97:  CALL   2E9
0A98:  BSF    0A.3
0A99:  MOVLW  0D
0A9A:  BTFSS  0C.4
0A9B:  GOTO   29A
0A9C:  MOVWF  19
....................          printf("Tinh bien do: nhan B hoac b");putc(13); 
0A9D:  MOVLW  58
0A9E:  BSF    03.6
0A9F:  MOVWF  0D
0AA0:  MOVLW  01
0AA1:  MOVWF  0F
0AA2:  BCF    0A.3
0AA3:  BCF    03.6
0AA4:  CALL   2E9
0AA5:  BSF    0A.3
0AA6:  MOVLW  0D
0AA7:  BTFSS  0C.4
0AA8:  GOTO   2A7
0AA9:  MOVWF  19
....................          printf("So phuc lien hop: nhan H hoac h");putc(13); 
0AAA:  MOVLW  66
0AAB:  BSF    03.6
0AAC:  MOVWF  0D
0AAD:  MOVLW  01
0AAE:  MOVWF  0F
0AAF:  BCF    0A.3
0AB0:  BCF    03.6
0AB1:  CALL   2E9
0AB2:  BSF    0A.3
0AB3:  MOVLW  0D
0AB4:  BTFSS  0C.4
0AB5:  GOTO   2B4
0AB6:  MOVWF  19
....................           signed long long a,b,a1,a2,b1,b2; 
....................           char cn1; 
....................        for (;;) 
....................          { 
....................             cn1 = getc(); 
0AB7:  BTFSS  0C.5
0AB8:  GOTO   2B7
0AB9:  MOVF   1A,W
0ABA:  MOVWF  3D
....................             if (cn1=='t'||cn1=='T') 
0ABB:  MOVF   3D,W
0ABC:  SUBLW  74
0ABD:  BTFSC  03.2
0ABE:  GOTO   2C3
0ABF:  MOVF   3D,W
0AC0:  SUBLW  54
0AC1:  BTFSS  03.2
0AC2:  GOTO   641
....................             { 
....................                printf("So phuc 1: a1 + jb1");putc(13); 
0AC3:  MOVLW  76
0AC4:  BSF    03.6
0AC5:  MOVWF  0D
0AC6:  MOVLW  01
0AC7:  MOVWF  0F
0AC8:  BCF    0A.3
0AC9:  BCF    03.6
0ACA:  CALL   2E9
0ACB:  BSF    0A.3
0ACC:  MOVLW  0D
0ACD:  BTFSS  0C.4
0ACE:  GOTO   2CD
0ACF:  MOVWF  19
....................                printf("Nhap a1: "); a1 = nhap_so();            
0AD0:  MOVLW  80
0AD1:  BSF    03.6
0AD2:  MOVWF  0D
0AD3:  MOVLW  01
0AD4:  MOVWF  0F
0AD5:  BCF    0A.3
0AD6:  BCF    03.6
0AD7:  CALL   2E9
0AD8:  BSF    0A.3
0AD9:  BCF    0A.3
0ADA:  CALL   391
0ADB:  BSF    0A.3
0ADC:  MOVF   7A,W
0ADD:  MOVWF  30
0ADE:  MOVF   79,W
0ADF:  MOVWF  2F
0AE0:  MOVF   78,W
0AE1:  MOVWF  2E
0AE2:  MOVF   77,W
0AE3:  MOVWF  2D
....................                printf("Nhap b1: "); b1 = nhap_so(); 
0AE4:  MOVLW  85
0AE5:  BSF    03.6
0AE6:  MOVWF  0D
0AE7:  MOVLW  01
0AE8:  MOVWF  0F
0AE9:  BCF    0A.3
0AEA:  BCF    03.6
0AEB:  CALL   2E9
0AEC:  BSF    0A.3
0AED:  BCF    0A.3
0AEE:  CALL   391
0AEF:  BSF    0A.3
0AF0:  MOVF   7A,W
0AF1:  MOVWF  38
0AF2:  MOVF   79,W
0AF3:  MOVWF  37
0AF4:  MOVF   78,W
0AF5:  MOVWF  36
0AF6:  MOVF   77,W
0AF7:  MOVWF  35
....................                printf("So phuc 2: a2 + jb2");putc(13); 
0AF8:  MOVLW  8A
0AF9:  BSF    03.6
0AFA:  MOVWF  0D
0AFB:  MOVLW  01
0AFC:  MOVWF  0F
0AFD:  BCF    0A.3
0AFE:  BCF    03.6
0AFF:  CALL   2E9
0B00:  BSF    0A.3
0B01:  MOVLW  0D
0B02:  BTFSS  0C.4
0B03:  GOTO   302
0B04:  MOVWF  19
....................                printf("Nhap a2: "); a2 = nhap_so(); 
0B05:  MOVLW  94
0B06:  BSF    03.6
0B07:  MOVWF  0D
0B08:  MOVLW  01
0B09:  MOVWF  0F
0B0A:  BCF    0A.3
0B0B:  BCF    03.6
0B0C:  CALL   2E9
0B0D:  BSF    0A.3
0B0E:  BCF    0A.3
0B0F:  CALL   391
0B10:  BSF    0A.3
0B11:  MOVF   7A,W
0B12:  MOVWF  34
0B13:  MOVF   79,W
0B14:  MOVWF  33
0B15:  MOVF   78,W
0B16:  MOVWF  32
0B17:  MOVF   77,W
0B18:  MOVWF  31
....................                printf("Nhap b2: "); b2 = nhap_so(); 
0B19:  MOVLW  99
0B1A:  BSF    03.6
0B1B:  MOVWF  0D
0B1C:  MOVLW  01
0B1D:  MOVWF  0F
0B1E:  BCF    0A.3
0B1F:  BCF    03.6
0B20:  CALL   2E9
0B21:  BSF    0A.3
0B22:  BCF    0A.3
0B23:  CALL   391
0B24:  BSF    0A.3
0B25:  MOVF   7A,W
0B26:  MOVWF  3C
0B27:  MOVF   79,W
0B28:  MOVWF  3B
0B29:  MOVF   78,W
0B2A:  MOVWF  3A
0B2B:  MOVF   77,W
0B2C:  MOVWF  39
....................                printf("Nhap phep tinh: "); 
0B2D:  MOVLW  9E
0B2E:  BSF    03.6
0B2F:  MOVWF  0D
0B30:  MOVLW  01
0B31:  MOVWF  0F
0B32:  BCF    0A.3
0B33:  BCF    03.6
0B34:  CALL   2E9
0B35:  BSF    0A.3
....................                switch(getc()) 
0B36:  BTFSS  0C.5
0B37:  GOTO   336
0B38:  MOVF   1A,W
0B39:  ADDLW  D6
0B3A:  ADDLW  FA
0B3B:  BTFSC  03.0
0B3C:  GOTO   640
0B3D:  ADDLW  06
0B3E:  GOTO   759
....................                { 
....................                case plus:printf("+");putc(13);printf("Ket qua la: %ld + j(%ld)",a1+a2,b1+b2);putc(13);break;                             
0B3F:  MOVLW  2B
0B40:  BTFSS  0C.4
0B41:  GOTO   340
0B42:  MOVWF  19
0B43:  MOVLW  0D
0B44:  BTFSS  0C.4
0B45:  GOTO   344
0B46:  MOVWF  19
0B47:  MOVF   31,W
0B48:  ADDWF  2D,W
0B49:  MOVWF  4E
0B4A:  MOVF   2E,W
0B4B:  MOVWF  4F
0B4C:  MOVF   32,W
0B4D:  BTFSC  03.0
0B4E:  INCFSZ 32,W
0B4F:  ADDWF  4F,F
0B50:  MOVF   2F,W
0B51:  MOVWF  50
0B52:  MOVF   33,W
0B53:  BTFSC  03.0
0B54:  INCFSZ 33,W
0B55:  ADDWF  50,F
0B56:  MOVF   30,W
0B57:  MOVWF  51
0B58:  MOVF   34,W
0B59:  BTFSC  03.0
0B5A:  INCFSZ 34,W
0B5B:  ADDWF  51,F
0B5C:  MOVF   39,W
0B5D:  ADDWF  35,W
0B5E:  MOVWF  52
0B5F:  MOVF   36,W
0B60:  MOVWF  53
0B61:  MOVF   3A,W
0B62:  BTFSC  03.0
0B63:  INCFSZ 3A,W
0B64:  ADDWF  53,F
0B65:  MOVF   37,W
0B66:  MOVWF  54
0B67:  MOVF   3B,W
0B68:  BTFSC  03.0
0B69:  INCFSZ 3B,W
0B6A:  ADDWF  54,F
0B6B:  MOVF   38,W
0B6C:  MOVWF  55
0B6D:  MOVF   3C,W
0B6E:  BTFSC  03.0
0B6F:  INCFSZ 3C,W
0B70:  ADDWF  55,F
0B71:  MOVLW  A7
0B72:  BSF    03.6
0B73:  MOVWF  0D
0B74:  MOVLW  01
0B75:  MOVWF  0F
0B76:  BCF    03.0
0B77:  MOVLW  0C
0B78:  BCF    03.6
0B79:  MOVWF  56
0B7A:  BCF    0A.3
0B7B:  CALL   43F
0B7C:  BSF    0A.3
0B7D:  MOVLW  41
0B7E:  MOVWF  04
0B7F:  MOVF   51,W
0B80:  MOVWF  59
0B81:  MOVF   50,W
0B82:  MOVWF  58
0B83:  MOVF   4F,W
0B84:  MOVWF  57
0B85:  MOVF   4E,W
0B86:  MOVWF  56
0B87:  BCF    0A.3
0B88:  CALL   4E7
0B89:  BSF    0A.3
0B8A:  MOVLW  AE
0B8B:  BSF    03.6
0B8C:  MOVWF  0D
0B8D:  MOVLW  01
0B8E:  MOVWF  0F
0B8F:  BSF    03.0
0B90:  MOVLW  05
0B91:  BCF    03.6
0B92:  MOVWF  56
0B93:  BCF    0A.3
0B94:  CALL   43F
0B95:  BSF    0A.3
0B96:  MOVLW  41
0B97:  MOVWF  04
0B98:  MOVF   55,W
0B99:  MOVWF  59
0B9A:  MOVF   54,W
0B9B:  MOVWF  58
0B9C:  MOVF   53,W
0B9D:  MOVWF  57
0B9E:  MOVF   52,W
0B9F:  MOVWF  56
0BA0:  BCF    0A.3
0BA1:  CALL   4E7
0BA2:  BSF    0A.3
0BA3:  MOVLW  29
0BA4:  BTFSS  0C.4
0BA5:  GOTO   3A4
0BA6:  MOVWF  19
0BA7:  MOVLW  0D
0BA8:  BTFSS  0C.4
0BA9:  GOTO   3A8
0BAA:  MOVWF  19
0BAB:  GOTO   640
....................                case minus:printf("-");putc(13);printf("Ket qua la: %ld + j(%ld)",a1 - a2, b1 - b2);putc(13);break; 
0BAC:  MOVLW  2D
0BAD:  BTFSS  0C.4
0BAE:  GOTO   3AD
0BAF:  MOVWF  19
0BB0:  MOVLW  0D
0BB1:  BTFSS  0C.4
0BB2:  GOTO   3B1
0BB3:  MOVWF  19
0BB4:  MOVF   31,W
0BB5:  SUBWF  2D,W
0BB6:  MOVWF  4E
0BB7:  MOVF   2E,W
0BB8:  MOVWF  4F
0BB9:  MOVF   32,W
0BBA:  BTFSS  03.0
0BBB:  INCFSZ 32,W
0BBC:  SUBWF  4F,F
0BBD:  MOVF   2F,W
0BBE:  MOVWF  50
0BBF:  MOVF   33,W
0BC0:  BTFSS  03.0
0BC1:  INCFSZ 33,W
0BC2:  SUBWF  50,F
0BC3:  MOVF   30,W
0BC4:  MOVWF  51
0BC5:  MOVF   34,W
0BC6:  BTFSS  03.0
0BC7:  INCFSZ 34,W
0BC8:  SUBWF  51,F
0BC9:  MOVF   39,W
0BCA:  SUBWF  35,W
0BCB:  MOVWF  52
0BCC:  MOVF   36,W
0BCD:  MOVWF  53
0BCE:  MOVF   3A,W
0BCF:  BTFSS  03.0
0BD0:  INCFSZ 3A,W
0BD1:  SUBWF  53,F
0BD2:  MOVF   37,W
0BD3:  MOVWF  54
0BD4:  MOVF   3B,W
0BD5:  BTFSS  03.0
0BD6:  INCFSZ 3B,W
0BD7:  SUBWF  54,F
0BD8:  MOVF   38,W
0BD9:  MOVWF  55
0BDA:  MOVF   3C,W
0BDB:  BTFSS  03.0
0BDC:  INCFSZ 3C,W
0BDD:  SUBWF  55,F
0BDE:  MOVLW  B4
0BDF:  BSF    03.6
0BE0:  MOVWF  0D
0BE1:  MOVLW  01
0BE2:  MOVWF  0F
0BE3:  BCF    03.0
0BE4:  MOVLW  0C
0BE5:  BCF    03.6
0BE6:  MOVWF  56
0BE7:  BCF    0A.3
0BE8:  CALL   43F
0BE9:  BSF    0A.3
0BEA:  MOVLW  41
0BEB:  MOVWF  04
0BEC:  MOVF   51,W
0BED:  MOVWF  59
0BEE:  MOVF   50,W
0BEF:  MOVWF  58
0BF0:  MOVF   4F,W
0BF1:  MOVWF  57
0BF2:  MOVF   4E,W
0BF3:  MOVWF  56
0BF4:  BCF    0A.3
0BF5:  CALL   4E7
0BF6:  BSF    0A.3
0BF7:  MOVLW  BB
0BF8:  BSF    03.6
0BF9:  MOVWF  0D
0BFA:  MOVLW  01
0BFB:  MOVWF  0F
0BFC:  BSF    03.0
0BFD:  MOVLW  05
0BFE:  BCF    03.6
0BFF:  MOVWF  56
0C00:  BCF    0A.3
0C01:  CALL   43F
0C02:  BSF    0A.3
0C03:  MOVLW  41
0C04:  MOVWF  04
0C05:  MOVF   55,W
0C06:  MOVWF  59
0C07:  MOVF   54,W
0C08:  MOVWF  58
0C09:  MOVF   53,W
0C0A:  MOVWF  57
0C0B:  MOVF   52,W
0C0C:  MOVWF  56
0C0D:  BCF    0A.3
0C0E:  CALL   4E7
0C0F:  BSF    0A.3
0C10:  MOVLW  29
0C11:  BTFSS  0C.4
0C12:  GOTO   411
0C13:  MOVWF  19
0C14:  MOVLW  0D
0C15:  BTFSS  0C.4
0C16:  GOTO   415
0C17:  MOVWF  19
0C18:  GOTO   640
....................                case multiply: 
....................                  printf("*"); putc(13);printf("Ket qua la: %ld + j(%ld)",a1*a2-b1*b2,a1*b2+a2*b1);putc(13); 
0C19:  MOVLW  2A
0C1A:  BTFSS  0C.4
0C1B:  GOTO   41A
0C1C:  MOVWF  19
0C1D:  MOVLW  0D
0C1E:  BTFSS  0C.4
0C1F:  GOTO   41E
0C20:  MOVWF  19
0C21:  MOVF   30,W
0C22:  MOVWF  65
0C23:  MOVF   2F,W
0C24:  MOVWF  64
0C25:  MOVF   2E,W
0C26:  MOVWF  63
0C27:  MOVF   2D,W
0C28:  MOVWF  62
0C29:  MOVF   34,W
0C2A:  MOVWF  69
0C2B:  MOVF   33,W
0C2C:  MOVWF  68
0C2D:  MOVF   32,W
0C2E:  MOVWF  67
0C2F:  MOVF   31,W
0C30:  MOVWF  66
0C31:  BCF    0A.3
0C32:  CALL   367
0C33:  BSF    0A.3
0C34:  MOVF   7A,W
0C35:  MOVWF  51
0C36:  MOVF   79,W
0C37:  MOVWF  50
0C38:  MOVF   78,W
0C39:  MOVWF  4F
0C3A:  MOVF   77,W
0C3B:  MOVWF  4E
0C3C:  MOVF   38,W
0C3D:  MOVWF  65
0C3E:  MOVF   37,W
0C3F:  MOVWF  64
0C40:  MOVF   36,W
0C41:  MOVWF  63
0C42:  MOVF   35,W
0C43:  MOVWF  62
0C44:  MOVF   3C,W
0C45:  MOVWF  69
0C46:  MOVF   3B,W
0C47:  MOVWF  68
0C48:  MOVF   3A,W
0C49:  MOVWF  67
0C4A:  MOVF   39,W
0C4B:  MOVWF  66
0C4C:  BCF    0A.3
0C4D:  CALL   367
0C4E:  BSF    0A.3
0C4F:  MOVF   77,W
0C50:  SUBWF  4E,F
0C51:  MOVF   78,W
0C52:  BTFSS  03.0
0C53:  INCFSZ 78,W
0C54:  SUBWF  4F,F
0C55:  MOVF   79,W
0C56:  BTFSS  03.0
0C57:  INCFSZ 79,W
0C58:  SUBWF  50,F
0C59:  MOVF   7A,W
0C5A:  BTFSS  03.0
0C5B:  INCFSZ 7A,W
0C5C:  SUBWF  51,F
0C5D:  MOVF   30,W
0C5E:  MOVWF  65
0C5F:  MOVF   2F,W
0C60:  MOVWF  64
0C61:  MOVF   2E,W
0C62:  MOVWF  63
0C63:  MOVF   2D,W
0C64:  MOVWF  62
0C65:  MOVF   3C,W
0C66:  MOVWF  69
0C67:  MOVF   3B,W
0C68:  MOVWF  68
0C69:  MOVF   3A,W
0C6A:  MOVWF  67
0C6B:  MOVF   39,W
0C6C:  MOVWF  66
0C6D:  BCF    0A.3
0C6E:  CALL   367
0C6F:  BSF    0A.3
0C70:  MOVF   7A,W
0C71:  MOVWF  55
0C72:  MOVF   79,W
0C73:  MOVWF  54
0C74:  MOVF   78,W
0C75:  MOVWF  53
0C76:  MOVF   77,W
0C77:  MOVWF  52
0C78:  MOVF   34,W
0C79:  MOVWF  65
0C7A:  MOVF   33,W
0C7B:  MOVWF  64
0C7C:  MOVF   32,W
0C7D:  MOVWF  63
0C7E:  MOVF   31,W
0C7F:  MOVWF  62
0C80:  MOVF   38,W
0C81:  MOVWF  69
0C82:  MOVF   37,W
0C83:  MOVWF  68
0C84:  MOVF   36,W
0C85:  MOVWF  67
0C86:  MOVF   35,W
0C87:  MOVWF  66
0C88:  BCF    0A.3
0C89:  CALL   367
0C8A:  BSF    0A.3
0C8B:  MOVF   77,W
0C8C:  ADDWF  52,F
0C8D:  MOVF   78,W
0C8E:  BTFSC  03.0
0C8F:  INCFSZ 78,W
0C90:  ADDWF  53,F
0C91:  MOVF   79,W
0C92:  BTFSC  03.0
0C93:  INCFSZ 79,W
0C94:  ADDWF  54,F
0C95:  MOVF   7A,W
0C96:  BTFSC  03.0
0C97:  INCFSZ 7A,W
0C98:  ADDWF  55,F
0C99:  MOVLW  C1
0C9A:  BSF    03.6
0C9B:  MOVWF  0D
0C9C:  MOVLW  01
0C9D:  MOVWF  0F
0C9E:  BCF    03.0
0C9F:  MOVLW  0C
0CA0:  BCF    03.6
0CA1:  MOVWF  56
0CA2:  BCF    0A.3
0CA3:  CALL   43F
0CA4:  BSF    0A.3
0CA5:  MOVLW  41
0CA6:  MOVWF  04
0CA7:  MOVF   51,W
0CA8:  MOVWF  59
0CA9:  MOVF   50,W
0CAA:  MOVWF  58
0CAB:  MOVF   4F,W
0CAC:  MOVWF  57
0CAD:  MOVF   4E,W
0CAE:  MOVWF  56
0CAF:  BCF    0A.3
0CB0:  CALL   4E7
0CB1:  BSF    0A.3
0CB2:  MOVLW  C8
0CB3:  BSF    03.6
0CB4:  MOVWF  0D
0CB5:  MOVLW  01
0CB6:  MOVWF  0F
0CB7:  BSF    03.0
0CB8:  MOVLW  05
0CB9:  BCF    03.6
0CBA:  MOVWF  56
0CBB:  BCF    0A.3
0CBC:  CALL   43F
0CBD:  BSF    0A.3
0CBE:  MOVLW  41
0CBF:  MOVWF  04
0CC0:  MOVF   55,W
0CC1:  MOVWF  59
0CC2:  MOVF   54,W
0CC3:  MOVWF  58
0CC4:  MOVF   53,W
0CC5:  MOVWF  57
0CC6:  MOVF   52,W
0CC7:  MOVWF  56
0CC8:  BCF    0A.3
0CC9:  CALL   4E7
0CCA:  BSF    0A.3
0CCB:  MOVLW  29
0CCC:  BTFSS  0C.4
0CCD:  GOTO   4CC
0CCE:  MOVWF  19
0CCF:  MOVLW  0D
0CD0:  BTFSS  0C.4
0CD1:  GOTO   4D0
0CD2:  MOVWF  19
....................                   break; 
0CD3:  GOTO   640
....................                case divide:  
....................                   printf("/");putc(13); 
0CD4:  MOVLW  2F
0CD5:  BTFSS  0C.4
0CD6:  GOTO   4D5
0CD7:  MOVWF  19
0CD8:  MOVLW  0D
0CD9:  BTFSS  0C.4
0CDA:  GOTO   4D9
0CDB:  MOVWF  19
....................                   if (a2 == 0 || b2 == 0){loiSyntax();break;} 
0CDC:  MOVF   31,F
0CDD:  BTFSS  03.2
0CDE:  GOTO   4E8
0CDF:  MOVF   32,F
0CE0:  BTFSS  03.2
0CE1:  GOTO   4E8
0CE2:  MOVF   33,F
0CE3:  BTFSS  03.2
0CE4:  GOTO   4E8
0CE5:  MOVF   34,F
0CE6:  BTFSC  03.2
0CE7:  GOTO   4F4
0CE8:  MOVF   39,F
0CE9:  BTFSS  03.2
0CEA:  GOTO   4F9
0CEB:  MOVF   3A,F
0CEC:  BTFSS  03.2
0CED:  GOTO   4F9
0CEE:  MOVF   3B,F
0CEF:  BTFSS  03.2
0CF0:  GOTO   4F9
0CF1:  MOVF   3C,F
0CF2:  BTFSS  03.2
0CF3:  GOTO   4F9
0CF4:  BCF    0A.3
0CF5:  CALL   355
0CF6:  BSF    0A.3
0CF7:  GOTO   640
0CF8:  GOTO   640
....................                   else 
....................                   { 
....................                      float x=biendo(a2,b2)*biendo(a2,b2); 
....................                      float c,d; 
0CF9:  MOVF   34,W
0CFA:  MOVWF  55
0CFB:  MOVF   33,W
0CFC:  MOVWF  54
0CFD:  MOVF   32,W
0CFE:  MOVWF  53
0CFF:  MOVF   31,W
0D00:  MOVWF  52
0D01:  MOVF   3C,W
0D02:  MOVWF  59
0D03:  MOVF   3B,W
0D04:  MOVWF  58
0D05:  MOVF   3A,W
0D06:  MOVWF  57
0D07:  MOVF   39,W
0D08:  MOVWF  56
0D09:  CALL   182
0D0A:  MOVF   7A,W
0D0B:  MOVWF  51
0D0C:  MOVF   79,W
0D0D:  MOVWF  50
0D0E:  MOVF   78,W
0D0F:  MOVWF  4F
0D10:  MOVF   77,W
0D11:  MOVWF  4E
0D12:  MOVF   34,W
0D13:  MOVWF  55
0D14:  MOVF   33,W
0D15:  MOVWF  54
0D16:  MOVF   32,W
0D17:  MOVWF  53
0D18:  MOVF   31,W
0D19:  MOVWF  52
0D1A:  MOVF   3C,W
0D1B:  MOVWF  59
0D1C:  MOVF   3B,W
0D1D:  MOVWF  58
0D1E:  MOVF   3A,W
0D1F:  MOVWF  57
0D20:  MOVF   39,W
0D21:  MOVWF  56
0D22:  CALL   182
0D23:  MOVF   51,W
0D24:  MOVWF  5E
0D25:  MOVF   50,W
0D26:  MOVWF  5D
0D27:  MOVF   4F,W
0D28:  MOVWF  5C
0D29:  MOVF   4E,W
0D2A:  MOVWF  5B
0D2B:  MOVF   7A,W
0D2C:  MOVWF  62
0D2D:  MOVF   79,W
0D2E:  MOVWF  61
0D2F:  MOVF   78,W
0D30:  MOVWF  60
0D31:  MOVF   77,W
0D32:  MOVWF  5F
0D33:  BCF    0A.3
0D34:  CALL   66F
0D35:  BSF    0A.3
0D36:  MOVF   7A,W
0D37:  MOVWF  41
0D38:  MOVF   79,W
0D39:  MOVWF  40
0D3A:  MOVF   78,W
0D3B:  MOVWF  3F
0D3C:  MOVF   77,W
0D3D:  MOVWF  3E
....................                      c = ((a1*a2)+(b1*b2))/x; 
0D3E:  MOVF   30,W
0D3F:  MOVWF  65
0D40:  MOVF   2F,W
0D41:  MOVWF  64
0D42:  MOVF   2E,W
0D43:  MOVWF  63
0D44:  MOVF   2D,W
0D45:  MOVWF  62
0D46:  MOVF   34,W
0D47:  MOVWF  69
0D48:  MOVF   33,W
0D49:  MOVWF  68
0D4A:  MOVF   32,W
0D4B:  MOVWF  67
0D4C:  MOVF   31,W
0D4D:  MOVWF  66
0D4E:  BCF    0A.3
0D4F:  CALL   367
0D50:  BSF    0A.3
0D51:  MOVF   7A,W
0D52:  MOVWF  51
0D53:  MOVF   79,W
0D54:  MOVWF  50
0D55:  MOVF   78,W
0D56:  MOVWF  4F
0D57:  MOVF   77,W
0D58:  MOVWF  4E
0D59:  MOVF   38,W
0D5A:  MOVWF  65
0D5B:  MOVF   37,W
0D5C:  MOVWF  64
0D5D:  MOVF   36,W
0D5E:  MOVWF  63
0D5F:  MOVF   35,W
0D60:  MOVWF  62
0D61:  MOVF   3C,W
0D62:  MOVWF  69
0D63:  MOVF   3B,W
0D64:  MOVWF  68
0D65:  MOVF   3A,W
0D66:  MOVWF  67
0D67:  MOVF   39,W
0D68:  MOVWF  66
0D69:  BCF    0A.3
0D6A:  CALL   367
0D6B:  BSF    0A.3
0D6C:  MOVF   77,W
0D6D:  ADDWF  4E,F
0D6E:  MOVF   78,W
0D6F:  BTFSC  03.0
0D70:  INCFSZ 78,W
0D71:  ADDWF  4F,F
0D72:  MOVF   79,W
0D73:  BTFSC  03.0
0D74:  INCFSZ 79,W
0D75:  ADDWF  50,F
0D76:  MOVF   7A,W
0D77:  BTFSC  03.0
0D78:  INCFSZ 7A,W
0D79:  ADDWF  51,F
0D7A:  MOVF   51,W
0D7B:  MOVWF  55
0D7C:  MOVF   50,W
0D7D:  MOVWF  54
0D7E:  MOVF   4F,W
0D7F:  MOVWF  53
0D80:  MOVF   4E,W
0D81:  MOVWF  52
0D82:  BCF    0A.3
0D83:  CALL   568
0D84:  BSF    0A.3
0D85:  MOVF   7A,W
0D86:  MOVWF  73
0D87:  MOVF   79,W
0D88:  MOVWF  72
0D89:  MOVF   78,W
0D8A:  MOVWF  71
0D8B:  MOVF   77,W
0D8C:  MOVWF  70
0D8D:  MOVF   41,W
0D8E:  MOVWF  7E
0D8F:  MOVF   40,W
0D90:  MOVWF  7D
0D91:  MOVF   3F,W
0D92:  MOVWF  7C
0D93:  MOVF   3E,W
0D94:  MOVWF  7B
0D95:  BCF    0A.3
0D96:  CALL   596
0D97:  BSF    0A.3
0D98:  MOVF   7A,W
0D99:  MOVWF  45
0D9A:  MOVF   79,W
0D9B:  MOVWF  44
0D9C:  MOVF   78,W
0D9D:  MOVWF  43
0D9E:  MOVF   77,W
0D9F:  MOVWF  42
....................                      d = ((b1*a2)-(a1*b2))/x; 
0DA0:  MOVF   38,W
0DA1:  MOVWF  65
0DA2:  MOVF   37,W
0DA3:  MOVWF  64
0DA4:  MOVF   36,W
0DA5:  MOVWF  63
0DA6:  MOVF   35,W
0DA7:  MOVWF  62
0DA8:  MOVF   34,W
0DA9:  MOVWF  69
0DAA:  MOVF   33,W
0DAB:  MOVWF  68
0DAC:  MOVF   32,W
0DAD:  MOVWF  67
0DAE:  MOVF   31,W
0DAF:  MOVWF  66
0DB0:  BCF    0A.3
0DB1:  CALL   367
0DB2:  BSF    0A.3
0DB3:  MOVF   7A,W
0DB4:  MOVWF  51
0DB5:  MOVF   79,W
0DB6:  MOVWF  50
0DB7:  MOVF   78,W
0DB8:  MOVWF  4F
0DB9:  MOVF   77,W
0DBA:  MOVWF  4E
0DBB:  MOVF   30,W
0DBC:  MOVWF  65
0DBD:  MOVF   2F,W
0DBE:  MOVWF  64
0DBF:  MOVF   2E,W
0DC0:  MOVWF  63
0DC1:  MOVF   2D,W
0DC2:  MOVWF  62
0DC3:  MOVF   3C,W
0DC4:  MOVWF  69
0DC5:  MOVF   3B,W
0DC6:  MOVWF  68
0DC7:  MOVF   3A,W
0DC8:  MOVWF  67
0DC9:  MOVF   39,W
0DCA:  MOVWF  66
0DCB:  BCF    0A.3
0DCC:  CALL   367
0DCD:  BSF    0A.3
0DCE:  MOVF   77,W
0DCF:  SUBWF  4E,F
0DD0:  MOVF   78,W
0DD1:  BTFSS  03.0
0DD2:  INCFSZ 78,W
0DD3:  SUBWF  4F,F
0DD4:  MOVF   79,W
0DD5:  BTFSS  03.0
0DD6:  INCFSZ 79,W
0DD7:  SUBWF  50,F
0DD8:  MOVF   7A,W
0DD9:  BTFSS  03.0
0DDA:  INCFSZ 7A,W
0DDB:  SUBWF  51,F
0DDC:  MOVF   51,W
0DDD:  MOVWF  55
0DDE:  MOVF   50,W
0DDF:  MOVWF  54
0DE0:  MOVF   4F,W
0DE1:  MOVWF  53
0DE2:  MOVF   4E,W
0DE3:  MOVWF  52
0DE4:  BCF    0A.3
0DE5:  CALL   568
0DE6:  BSF    0A.3
0DE7:  MOVF   7A,W
0DE8:  MOVWF  73
0DE9:  MOVF   79,W
0DEA:  MOVWF  72
0DEB:  MOVF   78,W
0DEC:  MOVWF  71
0DED:  MOVF   77,W
0DEE:  MOVWF  70
0DEF:  MOVF   41,W
0DF0:  MOVWF  7E
0DF1:  MOVF   40,W
0DF2:  MOVWF  7D
0DF3:  MOVF   3F,W
0DF4:  MOVWF  7C
0DF5:  MOVF   3E,W
0DF6:  MOVWF  7B
0DF7:  BCF    0A.3
0DF8:  CALL   596
0DF9:  BSF    0A.3
0DFA:  MOVF   7A,W
0DFB:  MOVWF  49
0DFC:  MOVF   79,W
0DFD:  MOVWF  48
0DFE:  MOVF   78,W
0DFF:  MOVWF  47
0E00:  MOVF   77,W
0E01:  MOVWF  46
....................                      printf("Ket qua la: %f +j(%f)",c,d); putc(13); 
0E02:  MOVLW  CE
0E03:  BSF    03.6
0E04:  MOVWF  0D
0E05:  MOVLW  01
0E06:  MOVWF  0F
0E07:  BCF    03.0
0E08:  MOVLW  0C
0E09:  BCF    03.6
0E0A:  MOVWF  56
0E0B:  BCF    0A.3
0E0C:  CALL   43F
0E0D:  BSF    0A.3
0E0E:  MOVLW  89
0E0F:  MOVWF  04
0E10:  MOVF   45,W
0E11:  MOVWF  51
0E12:  MOVF   44,W
0E13:  MOVWF  50
0E14:  MOVF   43,W
0E15:  MOVWF  4F
0E16:  MOVF   42,W
0E17:  MOVWF  4E
0E18:  MOVLW  02
0E19:  MOVWF  52
0E1A:  BCF    0A.3
0E1B:  CALL   6E4
0E1C:  BSF    0A.3
0E1D:  MOVLW  D5
0E1E:  BSF    03.6
0E1F:  MOVWF  0D
0E20:  MOVLW  01
0E21:  MOVWF  0F
0E22:  BCF    03.0
0E23:  MOVLW  04
0E24:  BCF    03.6
0E25:  MOVWF  56
0E26:  BCF    0A.3
0E27:  CALL   43F
0E28:  BSF    0A.3
0E29:  MOVLW  89
0E2A:  MOVWF  04
0E2B:  MOVF   49,W
0E2C:  MOVWF  51
0E2D:  MOVF   48,W
0E2E:  MOVWF  50
0E2F:  MOVF   47,W
0E30:  MOVWF  4F
0E31:  MOVF   46,W
0E32:  MOVWF  4E
0E33:  MOVLW  02
0E34:  MOVWF  52
0E35:  BCF    0A.3
0E36:  CALL   6E4
0E37:  BSF    0A.3
0E38:  MOVLW  29
0E39:  BTFSS  0C.4
0E3A:  GOTO   639
0E3B:  MOVWF  19
0E3C:  MOVLW  0D
0E3D:  BTFSS  0C.4
0E3E:  GOTO   63D
0E3F:  MOVWF  19
....................                   } 
....................                   break;                  
....................                } 
....................                //break; 
....................             } 
0E40:  GOTO   747
....................             else if (cn1 == 'b' || cn1 == 'B') 
0E41:  MOVF   3D,W
0E42:  SUBLW  62
0E43:  BTFSC  03.2
0E44:  GOTO   649
0E45:  MOVF   3D,W
0E46:  SUBLW  42
0E47:  BTFSS  03.2
0E48:  GOTO   6B8
....................             { 
....................                printf("So phuc :A = a + jb");putc(13); 
0E49:  MOVLW  D9
0E4A:  BSF    03.6
0E4B:  MOVWF  0D
0E4C:  MOVLW  01
0E4D:  MOVWF  0F
0E4E:  BCF    0A.3
0E4F:  BCF    03.6
0E50:  CALL   2E9
0E51:  BSF    0A.3
0E52:  MOVLW  0D
0E53:  BTFSS  0C.4
0E54:  GOTO   653
0E55:  MOVWF  19
....................                printf("Nhap a: "); a = nhap_so(); 
0E56:  MOVLW  E3
0E57:  BSF    03.6
0E58:  MOVWF  0D
0E59:  MOVLW  01
0E5A:  MOVWF  0F
0E5B:  BCF    0A.3
0E5C:  BCF    03.6
0E5D:  CALL   2E9
0E5E:  BSF    0A.3
0E5F:  BCF    0A.3
0E60:  CALL   391
0E61:  BSF    0A.3
0E62:  MOVF   7A,W
0E63:  MOVWF  28
0E64:  MOVF   79,W
0E65:  MOVWF  27
0E66:  MOVF   78,W
0E67:  MOVWF  26
0E68:  MOVF   77,W
0E69:  MOVWF  25
....................                printf("Nhap b: "); b = nhap_so(); 
0E6A:  MOVLW  E8
0E6B:  BSF    03.6
0E6C:  MOVWF  0D
0E6D:  MOVLW  01
0E6E:  MOVWF  0F
0E6F:  BCF    0A.3
0E70:  BCF    03.6
0E71:  CALL   2E9
0E72:  BSF    0A.3
0E73:  BCF    0A.3
0E74:  CALL   391
0E75:  BSF    0A.3
0E76:  MOVF   7A,W
0E77:  MOVWF  2C
0E78:  MOVF   79,W
0E79:  MOVWF  2B
0E7A:  MOVF   78,W
0E7B:  MOVWF  2A
0E7C:  MOVF   77,W
0E7D:  MOVWF  29
....................                float x =biendo(a,b); 
0E7E:  MOVF   28,W
0E7F:  MOVWF  55
0E80:  MOVF   27,W
0E81:  MOVWF  54
0E82:  MOVF   26,W
0E83:  MOVWF  53
0E84:  MOVF   25,W
0E85:  MOVWF  52
0E86:  MOVF   2C,W
0E87:  MOVWF  59
0E88:  MOVF   2B,W
0E89:  MOVWF  58
0E8A:  MOVF   2A,W
0E8B:  MOVWF  57
0E8C:  MOVF   29,W
0E8D:  MOVWF  56
0E8E:  CALL   182
0E8F:  MOVF   7A,W
0E90:  MOVWF  4D
0E91:  MOVF   79,W
0E92:  MOVWF  4C
0E93:  MOVF   78,W
0E94:  MOVWF  4B
0E95:  MOVF   77,W
0E96:  MOVWF  4A
....................                printf("Bien do = %f",x);putc(13);break; 
0E97:  MOVLW  ED
0E98:  BSF    03.6
0E99:  MOVWF  0D
0E9A:  MOVLW  01
0E9B:  MOVWF  0F
0E9C:  BCF    03.0
0E9D:  MOVLW  0A
0E9E:  BCF    03.6
0E9F:  MOVWF  56
0EA0:  BCF    0A.3
0EA1:  CALL   43F
0EA2:  BSF    0A.3
0EA3:  MOVLW  89
0EA4:  MOVWF  04
0EA5:  MOVF   4D,W
0EA6:  MOVWF  51
0EA7:  MOVF   4C,W
0EA8:  MOVWF  50
0EA9:  MOVF   4B,W
0EAA:  MOVWF  4F
0EAB:  MOVF   4A,W
0EAC:  MOVWF  4E
0EAD:  MOVLW  02
0EAE:  MOVWF  52
0EAF:  BCF    0A.3
0EB0:  CALL   6E4
0EB1:  BSF    0A.3
0EB2:  MOVLW  0D
0EB3:  BTFSS  0C.4
0EB4:  GOTO   6B3
0EB5:  MOVWF  19
0EB6:  GOTO   749
....................             } 
0EB7:  GOTO   747
....................             else if (cn1 == 'h' || cn1 == 'H') 
0EB8:  MOVF   3D,W
0EB9:  SUBLW  68
0EBA:  BTFSC  03.2
0EBB:  GOTO   6C0
0EBC:  MOVF   3D,W
0EBD:  SUBLW  48
0EBE:  BTFSS  03.2
0EBF:  GOTO   740
....................             { 
....................                printf("So phuc :A = a + jb");putc(13); 
0EC0:  MOVLW  F4
0EC1:  BSF    03.6
0EC2:  MOVWF  0D
0EC3:  MOVLW  01
0EC4:  MOVWF  0F
0EC5:  BCF    0A.3
0EC6:  BCF    03.6
0EC7:  CALL   2E9
0EC8:  BSF    0A.3
0EC9:  MOVLW  0D
0ECA:  BTFSS  0C.4
0ECB:  GOTO   6CA
0ECC:  MOVWF  19
....................                printf("Nhap a: "); a = nhap_so();  
0ECD:  MOVLW  FE
0ECE:  BSF    03.6
0ECF:  MOVWF  0D
0ED0:  MOVLW  01
0ED1:  MOVWF  0F
0ED2:  BCF    0A.3
0ED3:  BCF    03.6
0ED4:  CALL   2E9
0ED5:  BSF    0A.3
0ED6:  BCF    0A.3
0ED7:  CALL   391
0ED8:  BSF    0A.3
0ED9:  MOVF   7A,W
0EDA:  MOVWF  28
0EDB:  MOVF   79,W
0EDC:  MOVWF  27
0EDD:  MOVF   78,W
0EDE:  MOVWF  26
0EDF:  MOVF   77,W
0EE0:  MOVWF  25
....................                printf("Nhap b: "); b = nhap_so();  
0EE1:  MOVLW  03
0EE2:  BSF    03.6
0EE3:  MOVWF  0D
0EE4:  MOVLW  02
0EE5:  MOVWF  0F
0EE6:  BCF    0A.3
0EE7:  BCF    03.6
0EE8:  CALL   2E9
0EE9:  BSF    0A.3
0EEA:  BCF    0A.3
0EEB:  CALL   391
0EEC:  BSF    0A.3
0EED:  MOVF   7A,W
0EEE:  MOVWF  2C
0EEF:  MOVF   79,W
0EF0:  MOVWF  2B
0EF1:  MOVF   78,W
0EF2:  MOVWF  2A
0EF3:  MOVF   77,W
0EF4:  MOVWF  29
....................                printf("Ket qua la: %ld + j(%ld)",a,-b);putc(13);break; 
0EF5:  COMF   29,W
0EF6:  MOVWF  4E
0EF7:  COMF   2A,W
0EF8:  MOVWF  4F
0EF9:  COMF   2B,W
0EFA:  MOVWF  50
0EFB:  COMF   2C,W
0EFC:  MOVWF  51
0EFD:  INCF   4E,F
0EFE:  BTFSC  03.2
0EFF:  INCF   4F,F
0F00:  BTFSC  03.2
0F01:  INCF   50,F
0F02:  BTFSC  03.2
0F03:  INCF   51,F
0F04:  MOVLW  08
0F05:  BSF    03.6
0F06:  MOVWF  0D
0F07:  MOVLW  02
0F08:  MOVWF  0F
0F09:  BCF    03.0
0F0A:  MOVLW  0C
0F0B:  BCF    03.6
0F0C:  MOVWF  56
0F0D:  BCF    0A.3
0F0E:  CALL   43F
0F0F:  BSF    0A.3
0F10:  MOVLW  41
0F11:  MOVWF  04
0F12:  MOVF   28,W
0F13:  MOVWF  59
0F14:  MOVF   27,W
0F15:  MOVWF  58
0F16:  MOVF   26,W
0F17:  MOVWF  57
0F18:  MOVF   25,W
0F19:  MOVWF  56
0F1A:  BCF    0A.3
0F1B:  CALL   4E7
0F1C:  BSF    0A.3
0F1D:  MOVLW  0F
0F1E:  BSF    03.6
0F1F:  MOVWF  0D
0F20:  MOVLW  02
0F21:  MOVWF  0F
0F22:  BSF    03.0
0F23:  MOVLW  05
0F24:  BCF    03.6
0F25:  MOVWF  56
0F26:  BCF    0A.3
0F27:  CALL   43F
0F28:  BSF    0A.3
0F29:  MOVLW  41
0F2A:  MOVWF  04
0F2B:  MOVF   51,W
0F2C:  MOVWF  59
0F2D:  MOVF   50,W
0F2E:  MOVWF  58
0F2F:  MOVF   4F,W
0F30:  MOVWF  57
0F31:  MOVF   4E,W
0F32:  MOVWF  56
0F33:  BCF    0A.3
0F34:  CALL   4E7
0F35:  BSF    0A.3
0F36:  MOVLW  29
0F37:  BTFSS  0C.4
0F38:  GOTO   737
0F39:  MOVWF  19
0F3A:  MOVLW  0D
0F3B:  BTFSS  0C.4
0F3C:  GOTO   73B
0F3D:  MOVWF  19
0F3E:  GOTO   749
....................             } 
0F3F:  GOTO   747
....................             else{loiSyntax();putc(13);} 
0F40:  BCF    0A.3
0F41:  CALL   355
0F42:  BSF    0A.3
0F43:  MOVLW  0D
0F44:  BTFSS  0C.4
0F45:  GOTO   744
0F46:  MOVWF  19
....................             break; 
0F47:  GOTO   749
0F48:  GOTO   2B7
....................          } 
....................        printf("Ket thuc mien phuc");putc(13);break; 
0F49:  MOVLW  15
0F4A:  BSF    03.6
0F4B:  MOVWF  0D
0F4C:  MOVLW  02
0F4D:  MOVWF  0F
0F4E:  BCF    0A.3
0F4F:  BCF    03.6
0F50:  CALL   2E9
0F51:  BSF    0A.3
0F52:  MOVLW  0D
0F53:  BTFSS  0C.4
0F54:  GOTO   753
0F55:  MOVWF  19
0F56:  BCF    0A.3
0F57:  BSF    0A.4
0F58:  GOTO   72E (RETURN)
....................       } // ket thuc mien phuc 
....................        
....................  
.................... #include <hang.c> 
.................... #use delay(clock=20M) 
.................... #use rs232(baud=9600,xmit=PIN_C6,rcv=PIN_C7) 
....................  
.................... void hang() 
.................... { 
....................          printf("So pi: nhan P hoac p");putc(13); 
*
1042:  MOVLW  1F
1043:  BSF    03.6
1044:  MOVWF  0D
1045:  MOVLW  02
1046:  MOVWF  0F
1047:  BCF    0A.4
1048:  BCF    03.6
1049:  CALL   2E9
104A:  BSF    0A.4
104B:  MOVLW  0D
104C:  BTFSS  0C.4
104D:  GOTO   04C
104E:  MOVWF  19
....................          printf("Hang so tu tham u: nhan u");putc(13); 
104F:  MOVLW  2A
1050:  BSF    03.6
1051:  MOVWF  0D
1052:  MOVLW  02
1053:  MOVWF  0F
1054:  BCF    0A.4
1055:  BCF    03.6
1056:  CALL   2E9
1057:  BSF    0A.4
1058:  MOVLW  0D
1059:  BTFSS  0C.4
105A:  GOTO   059
105B:  MOVWF  19
....................          printf("Hang so dien tham e: nhan Tab");putc(13); 
105C:  MOVLW  37
105D:  BSF    03.6
105E:  MOVWF  0D
105F:  MOVLW  02
1060:  MOVWF  0F
1061:  BCF    0A.4
1062:  BCF    03.6
1063:  CALL   2E9
1064:  BSF    0A.4
1065:  MOVLW  0D
1066:  BTFSS  0C.4
1067:  GOTO   066
1068:  MOVWF  19
....................          printf("He so Euler: nhan e");putc(13); 
1069:  MOVLW  46
106A:  BSF    03.6
106B:  MOVWF  0D
106C:  MOVLW  02
106D:  MOVWF  0F
106E:  BCF    0A.4
106F:  BCF    03.6
1070:  CALL   2E9
1071:  BSF    0A.4
1072:  MOVLW  0D
1073:  BTFSS  0C.4
1074:  GOTO   073
1075:  MOVWF  19
....................          printf("Toc do anh sang: nhan c");putc(13); 
1076:  MOVLW  50
1077:  BSF    03.6
1078:  MOVWF  0D
1079:  MOVLW  02
107A:  MOVWF  0F
107B:  BCF    0A.4
107C:  BCF    03.6
107D:  CALL   2E9
107E:  BSF    0A.4
107F:  MOVLW  0D
1080:  BTFSS  0C.4
1081:  GOTO   080
1082:  MOVWF  19
....................          char cn =getc(); 
1083:  BTFSS  0C.5
1084:  GOTO   083
1085:  MOVF   1A,W
1086:  MOVWF  25
....................          if (cn == 'p' || cn=='P') {printf("pi = 3.14159");putc(13);} 
1087:  MOVF   25,W
1088:  SUBLW  70
1089:  BTFSC  03.2
108A:  GOTO   08F
108B:  MOVF   25,W
108C:  SUBLW  50
108D:  BTFSS  03.2
108E:  GOTO   09D
108F:  MOVLW  5C
1090:  BSF    03.6
1091:  MOVWF  0D
1092:  MOVLW  02
1093:  MOVWF  0F
1094:  BCF    0A.4
1095:  BCF    03.6
1096:  CALL   2E9
1097:  BSF    0A.4
1098:  MOVLW  0D
1099:  BTFSS  0C.4
109A:  GOTO   099
109B:  MOVWF  19
109C:  GOTO   0E8
....................          else if (cn== 'u') {printf("Hang so tu tham u = 4pix10^-7");putc(13);} 
109D:  MOVF   25,W
109E:  SUBLW  75
109F:  BTFSS  03.2
10A0:  GOTO   0AF
10A1:  MOVLW  63
10A2:  BSF    03.6
10A3:  MOVWF  0D
10A4:  MOVLW  02
10A5:  MOVWF  0F
10A6:  BCF    0A.4
10A7:  BCF    03.6
10A8:  CALL   2E9
10A9:  BSF    0A.4
10AA:  MOVLW  0D
10AB:  BTFSS  0C.4
10AC:  GOTO   0AB
10AD:  MOVWF  19
10AE:  GOTO   0E8
....................          else if (cn== 9) {printf("Hang so dien tham e = 8.8542x10^-12");putc(13);} 
10AF:  MOVF   25,W
10B0:  SUBLW  09
10B1:  BTFSS  03.2
10B2:  GOTO   0C1
10B3:  MOVLW  72
10B4:  BSF    03.6
10B5:  MOVWF  0D
10B6:  MOVLW  02
10B7:  MOVWF  0F
10B8:  BCF    0A.4
10B9:  BCF    03.6
10BA:  CALL   2E9
10BB:  BSF    0A.4
10BC:  MOVLW  0D
10BD:  BTFSS  0C.4
10BE:  GOTO   0BD
10BF:  MOVWF  19
10C0:  GOTO   0E8
....................          else if (cn== 'e') {printf("He so Eule e = 2.71828 ");putc(13);} 
10C1:  MOVF   25,W
10C2:  SUBLW  65
10C3:  BTFSS  03.2
10C4:  GOTO   0D3
10C5:  MOVLW  84
10C6:  BSF    03.6
10C7:  MOVWF  0D
10C8:  MOVLW  02
10C9:  MOVWF  0F
10CA:  BCF    0A.4
10CB:  BCF    03.6
10CC:  CALL   2E9
10CD:  BSF    0A.4
10CE:  MOVLW  0D
10CF:  BTFSS  0C.4
10D0:  GOTO   0CF
10D1:  MOVWF  19
10D2:  GOTO   0E8
....................          else if (cn== 'c') {printf("Toc do anh sang c=3x10^8");putc(13);} 
10D3:  MOVF   25,W
10D4:  SUBLW  63
10D5:  BTFSS  03.2
10D6:  GOTO   0E5
10D7:  MOVLW  90
10D8:  BSF    03.6
10D9:  MOVWF  0D
10DA:  MOVLW  02
10DB:  MOVWF  0F
10DC:  BCF    0A.4
10DD:  BCF    03.6
10DE:  CALL   2E9
10DF:  BSF    0A.4
10E0:  MOVLW  0D
10E1:  BTFSS  0C.4
10E2:  GOTO   0E1
10E3:  MOVWF  19
10E4:  GOTO   0E8
....................          else {loiSyntax();} 
10E5:  BCF    0A.4
10E6:  CALL   355
10E7:  BSF    0A.4
....................           
.................... } 
....................  
....................  
.................... #use delay(clock=20M) 
*
0341:  MOVLW  25
0342:  MOVWF  04
0343:  BCF    03.7
0344:  MOVF   00,W
0345:  BTFSC  03.2
0346:  GOTO   354
0347:  MOVLW  06
0348:  MOVWF  78
0349:  CLRF   77
034A:  DECFSZ 77,F
034B:  GOTO   34A
034C:  DECFSZ 78,F
034D:  GOTO   349
034E:  MOVLW  7B
034F:  MOVWF  77
0350:  DECFSZ 77,F
0351:  GOTO   350
0352:  DECFSZ 00,F
0353:  GOTO   347
0354:  RETURN
.................... #use rs232(baud=9600,xmit=PIN_C6,rcv=PIN_C7) 
.................... //!void loiSyntax() 
.................... //!{ 
.................... //!    printf("Loi SYNTAX"); 
.................... //!    output_high(PIN_C0); 
.................... //!} 
.................... void chonmien() 
.................... { 
....................    printf("Mien thuc: nhan R hoac r"); 
*
1000:  MOVLW  9D
1001:  BSF    03.6
1002:  MOVWF  0D
1003:  MOVLW  02
1004:  MOVWF  0F
1005:  BCF    0A.4
1006:  BCF    03.6
1007:  CALL   2E9
1008:  BSF    0A.4
....................    putc(13); 
1009:  MOVLW  0D
100A:  BTFSS  0C.4
100B:  GOTO   00A
100C:  MOVWF  19
....................    delay_ms(100); 
100D:  MOVLW  64
100E:  MOVWF  25
100F:  BCF    0A.4
1010:  CALL   341
1011:  BSF    0A.4
....................    printf("Mien phuc: nhan C hoac c"); 
1012:  MOVLW  AA
1013:  BSF    03.6
1014:  MOVWF  0D
1015:  MOVLW  02
1016:  MOVWF  0F
1017:  BCF    0A.4
1018:  BCF    03.6
1019:  CALL   2E9
101A:  BSF    0A.4
....................    putc(13); 
101B:  MOVLW  0D
101C:  BTFSS  0C.4
101D:  GOTO   01C
101E:  MOVWF  19
....................    delay_ms(100); 
101F:  MOVLW  64
1020:  MOVWF  25
1021:  BCF    0A.4
1022:  CALL   341
1023:  BSF    0A.4
....................    printf("Hang so: nhan H hoac h"); 
1024:  MOVLW  B7
1025:  BSF    03.6
1026:  MOVWF  0D
1027:  MOVLW  02
1028:  MOVWF  0F
1029:  BCF    0A.4
102A:  BCF    03.6
102B:  CALL   2E9
102C:  BSF    0A.4
....................    putc(13); 
102D:  MOVLW  0D
102E:  BTFSS  0C.4
102F:  GOTO   02E
1030:  MOVWF  19
....................    delay_ms(100); 
1031:  MOVLW  64
1032:  MOVWF  25
1033:  BCF    0A.4
1034:  CALL   341
1035:  BSF    0A.4
.................... } 
.................... void thuchien() 
.................... { 
....................    chonmien(); 
....................    char mien=getc(); 
1036:  BTFSS  0C.5
1037:  GOTO   036
1038:  MOVF   1A,W
1039:  MOVWF  24
....................    if(mien == 'H' || mien == 'h'){hang();} 
103A:  MOVF   24,W
103B:  SUBLW  48
103C:  BTFSC  03.2
103D:  GOTO   042
103E:  MOVF   24,W
103F:  SUBLW  68
1040:  BTFSS  03.2
1041:  GOTO   0E9
*
10E8:  GOTO   734
....................    else if (mien=='R' || mien =='r'){mienthuc();} 
10E9:  MOVF   24,W
10EA:  SUBLW  52
10EB:  BTFSC  03.2
10EC:  GOTO   0F1
10ED:  MOVF   24,W
10EE:  SUBLW  72
10EF:  BTFSS  03.2
10F0:  GOTO   723
*
1722:  GOTO   734
....................    else if (mien =='C'|| mien =='c'){mienphuc();} 
1723:  MOVF   24,W
1724:  SUBLW  43
1725:  BTFSC  03.2
1726:  GOTO   72B
1727:  MOVF   24,W
1728:  SUBLW  63
1729:  BTFSS  03.2
172A:  GOTO   731
172B:  BCF    0A.4
172C:  BSF    0A.3
172D:  GOTO   290
172E:  BSF    0A.4
172F:  BCF    0A.3
1730:  GOTO   734
....................    else {loiSyntax();} 
1731:  BCF    0A.4
1732:  CALL   355
1733:  BSF    0A.4
1734:  RETURN
.................... } 
.................... void main() 
*
0F63:  MOVF   03,W
0F64:  ANDLW  1F
0F65:  MOVWF  03
0F66:  MOVLW  81
0F67:  BSF    03.5
0F68:  MOVWF  19
0F69:  MOVLW  A6
0F6A:  MOVWF  18
0F6B:  MOVLW  90
0F6C:  BCF    03.5
0F6D:  MOVWF  18
0F6E:  MOVLW  FF
0F6F:  MOVWF  22
0F70:  MOVLW  81
0F71:  BSF    03.5
0F72:  MOVWF  19
0F73:  MOVLW  A6
0F74:  MOVWF  18
0F75:  MOVLW  90
0F76:  BCF    03.5
0F77:  MOVWF  18
0F78:  MOVLW  81
0F79:  BSF    03.5
0F7A:  MOVWF  19
0F7B:  MOVLW  A6
0F7C:  MOVWF  18
0F7D:  MOVLW  90
0F7E:  BCF    03.5
0F7F:  MOVWF  18
0F80:  MOVLW  81
0F81:  BSF    03.5
0F82:  MOVWF  19
0F83:  MOVLW  A6
0F84:  MOVWF  18
0F85:  MOVLW  90
0F86:  BCF    03.5
0F87:  MOVWF  18
0F88:  BSF    03.5
0F89:  BSF    1F.0
0F8A:  BSF    1F.1
0F8B:  BSF    1F.2
0F8C:  BCF    1F.3
0F8D:  MOVLW  07
0F8E:  MOVWF  1C
0F8F:  BCF    03.7
.................... { 
....................    setup_uart(9600); 
*
0F93:  MOVLW  81
0F94:  BSF    03.5
0F95:  MOVWF  19
0F96:  MOVLW  A6
0F97:  MOVWF  18
0F98:  MOVLW  90
0F99:  BCF    03.5
0F9A:  MOVWF  18
....................    // TODO: USER CODE!! 
....................    while(1) 
.................... { 
....................     
....................    //bat dau mien thuc 
....................    thuchien(); 
0F9B:  BSF    0A.4
0F9C:  BCF    0A.3
0F9D:  CALL   000
0F9E:  BCF    0A.4
0F9F:  BSF    0A.3
....................    printf("Ban co muon tiep tuc!"); putc(13); 
0FA0:  MOVLW  C3
0FA1:  BSF    03.6
0FA2:  MOVWF  0D
0FA3:  MOVLW  02
0FA4:  MOVWF  0F
0FA5:  BCF    0A.3
0FA6:  BCF    03.6
0FA7:  CALL   2E9
0FA8:  BSF    0A.3
0FA9:  MOVLW  0D
0FAA:  BTFSS  0C.4
0FAB:  GOTO   7AA
0FAC:  MOVWF  19
....................    printf("Tiep tuc thi nhan C hoac c");putc(13); 
0FAD:  MOVLW  CE
0FAE:  BSF    03.6
0FAF:  MOVWF  0D
0FB0:  MOVLW  02
0FB1:  MOVWF  0F
0FB2:  BCF    0A.3
0FB3:  BCF    03.6
0FB4:  CALL   2E9
0FB5:  BSF    0A.3
0FB6:  MOVLW  0D
0FB7:  BTFSS  0C.4
0FB8:  GOTO   7B7
0FB9:  MOVWF  19
....................    char tt = getc(); 
0FBA:  BTFSS  0C.5
0FBB:  GOTO   7BA
0FBC:  MOVF   1A,W
0FBD:  MOVWF  23
....................    if (tt =='C'|| tt =='c') 
0FBE:  MOVF   23,W
0FBF:  SUBLW  43
0FC0:  BTFSC  03.2
0FC1:  GOTO   7C6
0FC2:  MOVF   23,W
0FC3:  SUBLW  63
0FC4:  BTFSS  03.2
0FC5:  GOTO   7D3
....................    { 
....................       tt = 0; 
0FC6:  CLRF   23
....................       output_low(pin_C0); 
0FC7:  BCF    22.0
0FC8:  MOVF   22,W
0FC9:  BSF    03.5
0FCA:  MOVWF  07
0FCB:  BCF    03.5
0FCC:  BCF    07.0
....................       thuchien(); 
0FCD:  BSF    0A.4
0FCE:  BCF    0A.3
0FCF:  CALL   000
0FD0:  BCF    0A.4
0FD1:  BSF    0A.3
....................    } 
0FD2:  GOTO   7EA
....................    else 
....................    { 
....................       printf("Xin cam on ban!");putc(13); 
0FD3:  MOVLW  DC
0FD4:  BSF    03.6
0FD5:  MOVWF  0D
0FD6:  MOVLW  02
0FD7:  MOVWF  0F
0FD8:  BCF    0A.3
0FD9:  BCF    03.6
0FDA:  CALL   2E9
0FDB:  BSF    0A.3
0FDC:  MOVLW  0D
0FDD:  BTFSS  0C.4
0FDE:  GOTO   7DD
0FDF:  MOVWF  19
....................       printf("KET THUC"); 
0FE0:  MOVLW  E4
0FE1:  BSF    03.6
0FE2:  MOVWF  0D
0FE3:  MOVLW  02
0FE4:  MOVWF  0F
0FE5:  BCF    0A.3
0FE6:  BCF    03.6
0FE7:  CALL   2E9
0FE8:  BSF    0A.3
....................       break; 
0FE9:  GOTO   7EB
....................    } 
0FEA:  GOTO   79B
.................... }} 
0FEB:  SLEEP

Configuration Fuses:
   Word  1: 3F32   HS NOWDT PUT NOBROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
